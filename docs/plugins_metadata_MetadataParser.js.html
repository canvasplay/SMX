<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">

  <title>JSDoc: Source-plugins/metadata/MetadataParser.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.rawgit.com/isagalaev/highlight.js/cf4b46e5/src/styles/default.css">
  <link rel="stylesheet" href="css/styles.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

</head>

<body>

<nav>
  <h2><a href="index.html">smx</a></h2><h3>Namespaces</h3><ul><li><a href="smx.html">smx</a></li></ul><h3>Classes</h3><ul><li> &rarr; <a href="smx.Document.html">Document</a></li><li> &rarr; <a href="smx.Loader.html">Loader</a></li><li> &rarr; <a href="smx.Node.html">Node</a></li><li> &rarr; <a href="smx.Playhead.html">Playhead</a></li></ul><h3>Modules</h3><ul><li><a href="module-Metadata.html">Metadata</a></li><li> &rarr; <a href="module-Metadata.module_MetadataParser.html">MetadataParser</a></li><li><a href="module-Prototype.html">Prototype</a></li><li> &rarr; <a href="module-Prototype.module_PrototypeParser.html">PrototypeParser</a></li><li><a href="module-Taxonomy.html">Taxonomy</a></li><li> &rarr; <a href="module-Taxonomy.module_TaxonomyParser.html">TaxonomyParser</a></li><li><a href="module-Ui.html">Ui</a></li></ul><h3>Mixins</h3><ul><li><a href="Node-AttributeGetters.html">Node-AttributeGetters</a></li><li><a href="Node-Core.html">Node-Core</a></li><li><a href="Node-TreeNode.html">Node-TreeNode</a></li><li> &rarr; <a href="module-Metadata.Document-Metadata.html">Document-Metadata</a></li><li> &rarr; <a href="module-Metadata.Node-Metadata.html">Node-Metadata</a></li><li> &rarr; <a href="module-Taxonomy.Node-Taxonomy.html">Node-Taxonomy</a></li><li> &rarr; <a href="module-Ui.Node-Ui.html">Node-Ui</a></li></ul>

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on 2018-02-12T23:28:45.229Z
  </footer>
</nav>

<div id="main">

    <h1 class="page-title">
      
        <small>Source</small>
      
      plugins/metadata/MetadataParser.js
    </h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * SMX Metadata Parser
 * @module MetadataParser
 * @memberof module:Metadata
 */
 
import Sizzle from './Sizzle.selectors.filters.meta.js';

//local helper
var escapeHtml = function(html){
  var map = {
    '&amp;': '&amp;amp;',
    '&lt;': '&amp;lt;',
    '>': '&amp;gt;',
    '"': '&amp;quot;',
    "'": '&amp;#039;'
  };
  return html.replace(/[&amp;&lt;>"']/g,(m)=>map[m]);
};

/**
 * Parses the given XMLDocument
 * @param {XMLDocument} xml
 * @param {Object} options
 * @async
 */
var parseXML = function(xml, opt){

    var XML = xml;

    //validate XML
    if(!XML) return;

    //normalize options
    var options = _.extend({
        data: {},
        callback: function(){ return },
        total: 0,
        nodes: null,
        max_iterations: 25
    },opt);


    // get all unparsed nodes based on flag attr
    // `metadata-processed` attribute is added while parsing process
    // nodes missing the flag attr are the nodes we need to parse
    var nodes;
    if(!options.nodes){
      //using Sizzle.selectors.filters.meta.js
      var selector = ['metadata,:meta'];
      nodes = Sizzle(selector.join(''), XML);
      //include root node itself to the list
      //nodes.unshift(XML);
    }
    else nodes = options.nodes;

    //calculate percent progress
    if(nodes.length > options.total) options.total = nodes.length;
    var percent =  Math.floor(100 - (nodes.length*100) / options.total);


    log('METADATA PARSING... ('+ (options.total-nodes.length) +'/'+ options.total +') '+percent+'%');


    var i = 0;

    while(nodes.length &amp;&amp; i&lt;options.max_iterations){

        var node = nodes.shift();

        var result;

        if(node.nodeType==1){

            result = (node.nodeName == 'metadata' )? parseMetadataNode(node) : parseMetaAttributes(node);

            if(result){

                //create node data object if does not exists yet
                if (!options.data[result.id]) options.data[result.id] = {};

                //extend parent data object
                if(!_.isEmpty(result.data)) _.extend(options.data[result.id], result.data);

            }

        }


        i++;

    }


    //more nodes to parse?
    if(nodes.length){

        _.delay(_.bind(function(){ parseXML(XML,{
            data: options.data,
            callback: options.callback,
            total: options.total,
            nodes: nodes
        }) },this),0);

    }
    //complete! no more nodes to parse
    else{

        //remove all existing metadata-processed attributes
        //log('METADATA REMOVING FLAGS...' );
        var flagged_nodes = Sizzle('[metadata-processed]', XML);
        _.each(flagged_nodes,function(node){
            node.removeAttribute('metadata-processed');
        });

        log('METADATA COMPLETE!   ('+ options.total +'/'+ options.total +') 100%' );

        try{
            
            options.callback(XML,options.data);

        }catch(e){

            log('METADATA CALLBACK ERROR! '+ e.toString() );
        }
    }


    return;
};


/**
 * Parses the given XMLNode
 * @param {XMLNode} node
 * @return {Object} data
 */

var parseMetadataNode = function(node){

    //metadata node is required...
    if(!node || node.nodeName!=='metadata') return;

    //get direct metadata parent node
    var parent = node.parentNode;

    //no parent node? wtf!!
    if(!parent) return;

    //node id which to attach data parsed
    var id = parent.getAttribute('id');

    //instance returning data object
    var data = {};


    //get and remove metadata node from parent
    var md = parent.removeChild(node);

    for (var c =0; c&lt;md.childNodes.length; c++){

        var xmlNode = md.childNodes[c];

        var key = xmlNode.nodeName;

        var value;

        if (xmlNode.innerHTML){

            //is &lt;![CDATA ???
            var is_cdata = ( (xmlNode.innerHTML+'').indexOf('&lt;![CDATA') >= 0 );

            if(is_cdata){

                var _chilNodes = xmlNode.childNodes;

                var _cdata, i=0;

                while(!_cdata &amp;&amp; i&lt;_chilNodes.length){

                    var _node = _chilNodes[i];

                    if(_node &amp;&amp; _node.nodeType === 4 ) _cdata = _node;

                    i++
                }

                if(_node)   value = escapeHtml(_cdata.textContent+'');
                else        value = xmlNode.innerHTML;

            }
            else{

                value = xmlNode.innerHTML;
                                
                //trim unwanted trailing and leading whitespace
                value = (value+'').replace(/^\s+|\s+$/gm,'');


            }

        }
        else{

            var childs = xmlNode.childNodes;

            var str = '';

            if (childs.length){
                _.each(childs,function(item,index){
                    str+= item.xml || (new XMLSerializer()).serializeToString(item);
                });
            }

            value = str;
            
            //trim unwanted trailing and leading whitespace
            value = (value+'').replace(/^\s+|\s+$/gm,'');

        }

        //ignore text nodes, comment nodes, ...
        if(xmlNode.nodeType==1) data[key] = value;

    }


    return {
        'data': data,
        'id': id
    }

    
}

/**
 * Parses meta attributes from the given XMLNode
 * @param {XMLNode} node
 * @return {Object} data
 */

var parseMetaAttributes = function(node){

    if(!node) return;

    //instance the resultant data object
    var data = {};

    //node id which to attach data parsed
    var id = node.getAttribute('id');

    //get data from node attributes
    var attrs = node.attributes;

    var names = _.map(attrs,'name');
    var values = _.map(attrs,'value');

    var len = attrs.length;

    for(var i = 0; i &lt; len; i++) {
        var name = names[i];
        var value = values[i];
        if(name.indexOf("meta-") == 0){
          
            //remove meta- preffix
            name = name.substr(5);
            
            //trim unwanted trailing and leading whitespace
            value = (value+'').replace(/^\s+|\s+$/gm,'');
            
            //set new data entry
            data[name] = value;

            //remove the attribute
            node.removeAttribute("meta-"+name);
        }
            
    }


    //flag node with "metadata-processed" attr
    node.setAttribute('metadata-processed','true');


    return {
        'data': data,
        'id': id
    }
    

   
}

export default {
  parseXML: parseXML,
  parseMetadataNode: parseMetadataNode,
  parseMetaAttributes: parseMetaAttributes
};</code></pre>
        </article>
    </section>




</div>

<div class="nav__overlay" onclick="$('body').removeClass('nav-visible');">
</div>

<a class="nav__toggle" href="javascript:$('body').toggleClass('nav-visible');">
  <i class="material-icons">menu</i>
</a>

<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
