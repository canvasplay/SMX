<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: <small>Source: </small>plugins/metadata/MetadataParser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--<link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="styles/tranquil-heart.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
<script
  src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous"></script>
  <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, target-densitydpi=device-dpi" />
</head>

<body>

<nav>
  <h2><a href="index.html">smx</a></h2><h3>Namespaces</h3><ul><li><a href="$smx.html">$smx</a></li><li><a href="smx.html">smx</a></li><li><a href="smx.AttributeParsers.html">smx.AttributeParsers</a></li><li><a href="smx.NodeParsers.html">smx.NodeParsers</a></li><li><a href="smx.fn.html">smx.fn</a></li><li><a href="smx.time.html">smx.time</a></li><li><a href="smx.tracking.html">smx.tracking</a></li><li><a href="smx.tracking.attributes.html">smx.tracking.attributes</a></li></ul><h3>Classes</h3><ul><li><a href="Compiler.html">Compiler</a></li><li><a href="Loader.html">Loader</a></li><li><a href="Metadata.html">Metadata</a></li><li><a href="smx.Document.html">Document</a></li><li><a href="smx.Finder.html">Finder</a></li><li><a href="smx.Node.html">Node</a></li><li><a href="smx.Playhead.html">Playhead</a></li><li><a href="smx.PlayheadEvent.html">PlayheadEvent</a></li><li><a href="smx.time.Timeline.html">Timeline</a></li><li><a href="smx.time.TimelineEvent.html">TimelineEvent</a></li><li><a href="smx.time.Timer.html">Timer</a></li><li><a href="smx.tracking.TrackManager.html">TrackManager</a></li></ul><h3>Modules</h3><ul><li><a href="module-Node_Metadata.html">Node/Metadata</a></li><li><a href="module-Node_Time.html">Node/Time</a></li><li><a href="module-Node_Tracking.html">Node/Tracking</a></li><li><a href="module-Node_UI.html">Node/UI</a></li><li><a href="module-TimeAttrController.html">TimeAttrController</a></li><li><a href="module-UIAttrController.html">UIAttrController</a></li></ul><h3>Mixins</h3><ul><li><a href="TimeAttributeParser.html">TimeAttributeParser</a></li><li><a href="smx.fn.AttributeGetters.html">AttributeGetters</a></li><li><a href="smx.fn.Core.html">Core</a></li><li><a href="smx.fn.TreeNode.html">TreeNode</a></li></ul>

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on 2018-01-28T23:02:06.343Z
  </footer>
</nav>

<div id="main">

    <h1 class="page-title"><small>Source: </small>plugins/metadata/MetadataParser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>////////////////////////////////
// smx plugin
// METADATA PARSER
// will transform all &lt;metadata> nodes
// convert first level children nodes into meta-* attributes
// and apply those attributes to direct parent node

/**
 * SMX Metadata class
 * @class Metadata
 */
 
(function(global, Sizzle, smx){
 

    //private aux debug system
    var DEBUG = true; var LOG = function(str){ if (global.console&amp;&amp;global.console.log&amp;&amp;DEBUG) global.console.log('METADATA '+str) };

    var MetadataParser = {};


    //local helper
    var escapeHtml = function(text) {
      var map = {
        '&amp;': '&amp;amp;',
        '&lt;': '&amp;lt;',
        '>': '&amp;gt;',
        '"': '&amp;quot;',
        "'": '&amp;#039;'
      };
      return text.replace(/[&amp;&lt;>"']/g, function(m) { return map[m]; });
    };


    MetadataParser.parseXML = function(xml, opt){

        var XML = xml;

        //validate XML
        if(!XML) return;

        //normalize options
        var options = _.extend({
            data: {},
            callback: function(){ return },
            total: 0,
            nodes: null,
            max_iterations: 100
        },opt);


        // get all unparsed nodes based on flag attr
        // `metadata-processed` attribute is added while parsing process
        // nodes missing the flag attr are the nodes we need to parse
        var nodes;
        if(!options.nodes){
          /*
          var selector = [];
          selector.push('*'); //get all nodes as starting point
          selector.push(':not(prototype)'); //ignore prototype elements
          selector.push(':not(metadata *)'); //ignore contents of metadata elements
          selector.push(':not([metadata-processed])'); //ignore already processed nodes
          selector.push(':not([type] *)'); //ignore contents of nodes having type attribute
          */
          //using Sizzle.selectors.filters.meta.js
          var selector = ['metadata,:meta'];
          nodes = Sizzle(selector.join(''), XML);
          //include root node itself to the list
          nodes.unshift(XML);
        }
        else nodes = options.nodes;

        //calculate percent progress
        if(nodes.length > options.total) options.total = nodes.length;
        var percent =  Math.floor(100 - (nodes.length*100) / options.total);


        LOG('PARSING... ('+ (options.total-nodes.length) +'/'+ options.total +') '+percent+'%');


        var i = 0;

        while(nodes.length &amp;&amp; i&lt;options.max_iterations){

            var node = nodes.shift();

            var result;

            if(node.nodeType==1){

                result = (node.nodeName == 'metadata' )? this.parseMetadataNode(node) : this.parseMetaAttributes(node);

                if(result){

                    //create node data object if does not exists yet
                    if (!options.data[result.id]) options.data[result.id] = {};

                    //extend parent data object
                    if(!_.isEmpty(result.data)) _.extend(options.data[result.id], result.data);

                }

            }


            i++;

        }


        //more nodes to parse?
        if(nodes.length){

            _.delay(_.bind(function(){ this.parseXML(XML,{
                data: options.data,
                callback: options.callback,
                total: options.total,
                nodes: nodes
            }) },this),0);

        }
        //complete! no more nodes to parse
        else{

            //remove all existing metadata-processed attributes
            LOG( 'REMOVING FLAGS...' );
            var flagged_nodes = Sizzle('[metadata-processed]', XML);
            _.each(flagged_nodes,function(node){
                node.removeAttribute('metadata-processed');
            });

            LOG( 'COMPLETE! ('+ options.total +'/'+ options.total +') 100%' );

            try{
                
                options.callback(XML,options.data);

            }catch(e){

                LOG( 'CALLBACK ERROR! '+ e.toString() );
            }
        }


        return;
    };


    MetadataParser.parseMetadataNode = function(node){

        //metadata node is required...
        if(!node || node.nodeName!=='metadata') return;

        //get direct metadata parent node
        var parent = node.parentNode;

        //no parent node? wtf!!
        if(!parent) return;

        //node id which to attach data parsed
        var id = parent.getAttribute('id');

        //instance returning data object
        var data = {};


        //get and remove metadata node from parent
        var md = parent.removeChild(node);

        for (var c =0; c&lt;md.childNodes.length; c++){

            var xmlNode = md.childNodes[c];

            var key = xmlNode.nodeName;

            var value;

            if (xmlNode.innerHTML){

                //is &lt;![CDATA ???
                var is_cdata = ( (xmlNode.innerHTML+'').indexOf('&lt;![CDATA') >= 0 );

                if(is_cdata){

                    var _chilNodes = xmlNode.childNodes;

                    var _cdata, i=0;

                    while(!_cdata &amp;&amp; i&lt;_chilNodes.length){

                        var _node = _chilNodes[i];

                        if(_node &amp;&amp; _node.nodeType === 4 ) _cdata = _node;

                        i++
                    }

                    if(_node)   value = escapeHtml(_cdata.textContent+'');
                    else        value = xmlNode.innerHTML;

                }
                else{

                    value = xmlNode.innerHTML;
                                    
                    //trim unwanted trailing and leading whitespace
                    value = (value+'').replace(/^\s+|\s+$/gm,'');


                }

            }
            else{

                var childs = xmlNode.childNodes;

                var str = '';

                if (childs.length){
                    _.each(childs,function(item,index){
                        str+= item.xml || (new XMLSerializer()).serializeToString(item);
                    });
                }

                value = str;
                
                //trim unwanted trailing and leading whitespace
                value = (value+'').replace(/^\s+|\s+$/gm,'');

            }

            //ignore text nodes, comment nodes, ...
            if(xmlNode.nodeType==1) data[key] = value;

        }


        return {
            'data': data,
            'id': id
        }

        
    }


    MetadataParser.parseMetaAttributes = function(node){

        if(!node) return;
 
        //instance the resultant data object
        var data = {};

        //node id which to attach data parsed
        var id = node.getAttribute('id');

        //get data from node attributes
        var attrs = node.attributes;

        var names = _.map(attrs,'name');
        var values = _.map(attrs,'value');

        var len = attrs.length;

        for(var i = 0; i &lt; len; i++) {
            var name = names[i];
            var value = values[i];
            if(name.indexOf("meta-") == 0){
              
                //remove meta- preffix
                name = name.substr(5);
                
                //trim unwanted trailing and leading whitespace
                value = (value+'').replace(/^\s+|\s+$/gm,'');
                
                //set new data entry
                data[name] = value;

                //remove the attribute
                node.removeAttribute("meta-"+name);
            }
                
        }


        //flag node with "metadata-processed" attr
        node.setAttribute('metadata-processed','true');


        return {
            'data': data,
            'id': id
        }
        

       
    }


    //expose into global smx namespace
    smx.meta = MetadataParser;



})(window, window.Sizzle, window.smx);</code></pre>
        </article>
    </section>




</div>

<div class="nav__overlay" onclick="$('body').removeClass('nav-visible');">
</div>

<a class="nav__toggle" href="javascript:$('body').toggleClass('nav-visible');">
  <i class="material-icons">menu</i>
</a>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
