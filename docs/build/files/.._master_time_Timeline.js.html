<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..\master\time\Timeline.js - The Foo API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="The Foo API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.2.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Metadata.html">Metadata</a></li>
            
                <li><a href="..&#x2F;classes/Playhead.html">Playhead</a></li>
            
                <li><a href="..&#x2F;classes/Timeline.html">Timeline</a></li>
            
                <li><a href="..&#x2F;classes/Timer.html">Timer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Node.html">Node</a></li>
            
                <li><a href="..&#x2F;modules/smx.html">smx</a></li>
            
                <li><a href="..&#x2F;modules/SMXComputedAttributes.html">SMXComputedAttributes</a></li>
            
                <li><a href="..&#x2F;modules/SMXCoreAttributes.html">SMXCoreAttributes</a></li>
            
                <li><a href="..&#x2F;modules/SMXNode.html">SMXNode</a></li>
            
                <li><a href="..&#x2F;modules/TimeAttrController
Plugin Controller for attributes namespace with &#x27;ui&#x27;.html">TimeAttrController
Plugin Controller for attributes namespace with &#x27;ui&#x27;</a></li>
            
                <li><a href="..&#x2F;modules/Track Attributes.html">Track Attributes</a></li>
            
                <li><a href="..&#x2F;modules/UIAttrController
Plugin Controller for attributes namespaced with &#x27;ui-&#x27;.html">UIAttrController
Plugin Controller for attributes namespaced with &#x27;ui-&#x27;</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ..\master\time\Timeline.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**

Timeline Controller, Provides basic time handling

@class Timeline
@constructor
@uses Timer
@param node {Node} Node from which to create the timeline, required node using timeline

*&#x2F;

&#x2F;*

	· time
	. is_playing
	. is_ready
	· time2s[]
	. keyframes{}

	+ play
	+ replay
	+ next
	+ previous
	+ goTo

	! update
	! play
	! pause
	! seek
	! timemark


*&#x2F;

(function(smx){


&#x2F;**



*&#x2F;

	var SMXTimeline = function(node){

		if(!node) return;

		&#x2F;&#x2F;extends with events
		_.extend(this, Backbone.Events);


		&#x2F;**
		
		Node from which the timeline is created
		@property node {Node}

		*&#x2F;

		&#x2F;&#x2F;define node ref
		this.node = node;

		&#x2F;**
		
		Current time
		@property time {Number}
		@default 0

		*&#x2F;

		&#x2F;&#x2F;current time
		this.time = 0;

		&#x2F;&#x2F;time cache
		this.time2 = -2;
		

		&#x2F;&#x2F;TIMER ENGINES

		&#x2F;**
		
		Timer engine used for time tic tacking
		@property timer {Object}

		*&#x2F;

		&#x2F;&#x2F;used for playing
		this.timer = null;

		&#x2F;&#x2F;used for scrolling
		this.scroller = null;


		&#x2F;&#x2F;STATUS FLAGS

		this.is_playing = false;

		this.is_scrolling = false;

		this.is_ready = true;


		&#x2F;&#x2F;TIMELINE SELECTION
		&#x2F;&#x2F;Array containing all selected nodes
		this.activeNodes = [];


		&#x2F;&#x2F;KEYFRAMES
		this.keyFrames = {};


		this.debug = false;


		this.initialize = function(){

			this.createTimer();

			this.updateKeyFrames();

			return;
		};


		this.createTimer= function(){
		
			&#x2F;&#x2F;create timer engine
			this.timer = new smx.time.Timer();
			
			&#x2F;&#x2F;create observer for timer &#x27;update&#x27; event
			this.timer.on(&#x27;update&#x27;, this.update, this);

			&#x2F;&#x2F;create timer engine
			this.scroller = new smx.time.Timer();
			&#x2F;&#x2F;this.scroller.fps = 10;
			
			&#x2F;&#x2F;create observer for timer &#x27;update&#x27; event
			this.scroller.on(&#x27;update&#x27;, this.onscroll, this);

			return;
			
		};

		this.destroyTimer= function(){
		
			if (!this.timer) return;

			this.timer.off(&#x27;update&#x27;, this.update);
			
			this.timer.destroy();

			this.timer = null;

			if (!this.scroller) return;

			this.scroller.off(&#x27;update&#x27;, this.onscroll);
			
			this.scroller.destroy();

			this.scroller = null;

			return;
			
		};


		this.plugExtTimer = function(name, callback){

			if (!this.timer || !name || !callback) return;

			this.timer.plugExtEngine(name, callback);

			return;

		};


		this.unplugExtTimer = function(name){

			if (!this.timer || !name) return;

			this.timer.unplugExtEngine(name);

			return;

		};


		this.getDuration = function(){

			return this.node.getDuration();

		};


		this.updateKeyFrames = function(){
			
			&#x2F;&#x2F;create&#x2F;reset empty object
			this.keyFrames = {};


			&#x2F;&#x2F;get timemarks
			var childs = this.node.find(&#x27;*&#x27;);
			
			for (var i=0; i&lt;childs.length;i++){
			
				&#x2F;&#x2F;get tm
				var child =  childs[i];
				

				&#x2F;&#x2F;get resulting times
				var _startTime = child.offset(this.node);
				var _finishTime = child.offset(this.node) + child.getDuration();
				

				&#x2F;&#x2F;create activation keyframe at start time
				this._addKeyFrame(_startTime, child.id, 1);
				
				&#x2F;&#x2F;create deactivation keyframe at finish time
				this._addKeyFrame(_finishTime, child.id, 0);
				

			}


			this._sortKeyFrames();

			return;
				
		};

		this._addKeyFrame = function(t,id,action){

			&#x2F;&#x2F;if keyframe[t] does not exist create keyframe array
			if (!this.keyFrames[t+&#x27;&#x27;]) this.keyFrames[t+&#x27;&#x27;] = [];

			&#x2F;&#x2F;the push keyframe in array
			this.keyFrames[t+&#x27;&#x27;].push({ &#x27;id&#x27;:id, &#x27;action&#x27;: action });

			return;

		};


		this._sortKeyFrames = function(){

			&#x2F;&#x2F;sort keyframes
			var sorted_keyframes = {};
			var kfs = _.keys(this.keyFrames);
			kfs = _.sortBy(kfs, function(num){ return parseFloat(num); });
			for (var i=0; i&lt; kfs.length;i++){
				sorted_keyframes[kfs[i]] = this.keyFrames[kfs[i]];
			}
			this.keyFrames = sorted_keyframes;

			return;

		};




		&#x2F;**
	     * Method: Update timeline
	     * @param {Number} (optional) update timeline at given time
	     * @return {Boolean} success or not
	     *&#x2F;
		this.update = function(time){
			
			&#x2F;&#x2F;check for &quot;is_ready&quot; flag
			if (!this.is_ready) return;

			&#x2F;&#x2F;check for &quot;is_playing&quot; flag
			&#x2F;&#x2F;if (!this.is_playing) return;
			
			&#x2F;&#x2F;process parameter
			var t = (typeof time != &#x27;undefined&#x27;)? parseInt(time) : false;

			&#x2F;&#x2F;update time
			if (this.timer)	this.time = this.timer.time; &#x2F;&#x2F;update from timer
			else if(t!== false) this.time = t; &#x2F;&#x2F; update from parameter
			else return;

			&#x2F;&#x2F;prevent LEFT timeline offset
			if (this.time&lt;0) this.time = 0;

			&#x2F;&#x2F;prevent RIGHT timeline offset
			var max = this.getDuration()*1000;
			if (this.time&gt;=max){
				this.time = max;
				this.pause();	
			}


			&#x2F;&#x2F;check for keyframes
			t = Math.floor(this.time&#x2F;1000);
			if (this.time2 != t){
			
				var diff = t - this.time2;
				if (diff &gt; 0 &amp;&amp; Math.abs(diff) &lt;= 1){
			
					&#x2F;&#x2F;is linear progress

					&#x2F;&#x2F;get keyframes for this frame
					var kfs = this.keyFrames[t+&#x27;&#x27;];

					&#x2F;&#x2F;exist keyframes?
					if (kfs){
					
						&#x2F;&#x2F;debug.log(&#x27;keyframe found at &#x27;+t);

						for (var i=0; i&lt;kfs.length; i++ ){

							var kf = kfs[i];
							var node = this.node.getDocument().getNodeById(kf.id);
							var action = kf.action;

							if(action&gt;0)	this._enterNode(node);
							else{
								var last_frame = Math.floor(max&#x2F;1000);
								if (t!=last_frame) this._exitNode(node);	
							}
							

						}

						
					}

				}
				else{

					&#x2F;&#x2F;is not linear progress

					&#x2F;&#x2F;get keyframes names: [&#x27;0&#x27;,&#x27;5&#x27;,&#x27;12&#x27;,...]
					var kfs = _.keys(this.keyFrames);
					
					&#x2F;&#x2F;aux array for active nodes
					var active_nodes = [];

					&#x2F;&#x2F;loop trough keyframes before time t
					for (var k =0; k &lt; kfs.length &amp;&amp; parseInt(kfs[k])&lt;=parseInt(t); k++){

						var kf = this.keyFrames[kfs[k]];

						for (var i=0; i&lt;kf.length; i++ ){

							var item = kf[i];
							var node = this.node.getDocument().getNodeById(item.id);
							var action = item.action;

							var index = active_nodes.indexOf(node);

							if(action&gt;0) active_nodes.push(node);
							else active_nodes.splice(index, 1);	
							

						}

					}


					&#x2F;&#x2F;perform resulting &#x27;exit&#x27; nodes
					var need_exit = [];
					for (var i=0; i&lt; this.activeNodes.length; i++){
						var node = this.activeNodes[i];
						if(active_nodes.indexOf(node)&lt;0){
							need_exit.push(node);
						}
						
					}
					for (var i=0; i&lt; need_exit.length; i++) this._exitNode(need_exit[i]);

					&#x2F;&#x2F;perform resulting &#x27;enter&#x27; nodes
					for (var i=0; i&lt; active_nodes.length; i++) this._enterNode(active_nodes[i]);


				}



				&#x2F;&#x2F;this._debug(&#x27;-------------------------------&#x27;);
				&#x2F;&#x2F;for (var i=0; i&lt; this.activeNodes.length; i++) debug.log(&#x27;&#x27;+this.activeNodes[i].nodeName +&#x27;#&#x27;+this.activeNodes[i].id);

				&#x2F;&#x2F;update time2
				this.time2 = t;
				
			}


			&#x2F;&#x2F;console.log(this.activeNodes);

			&#x2F;&#x2F;create timeline event object
			var e = this.buildEventObject(this.node);

			&#x2F;&#x2F;notify &#x27;update&#x27;
			this.trigger(&#x27;update&#x27;, e);

			return ;
			
		};


		this.isActive = function(node_or_id){

			var node = node_or_id;

			if (typeof node_or_id == &#x27;string&#x27;) node = this.node.getDocument().getNodeById(node_or_id);

			if(!node) return;

			if(this.activeNodes.indexOf(node)&gt;=0) return true;

		};

		this._enterNode = function(node){

			&#x2F;&#x2F;check node
			if(!node) return;

			&#x2F;&#x2F;check if already active
			if (this.activeNodes.indexOf(node)&gt;=0) return;

			&#x2F;&#x2F;add to active nodes
			this.activeNodes.push(node);

			&#x2F;&#x2F;create timeline event object
			var e = this.buildEventObject(node);

			&#x2F;&#x2F;notify action
			this.trigger(&#x27;enter&#x27;,e);

			&#x2F;&#x2F;debug action
			this._debug(&#x27;TIMELINE !enter: &#x27;+ node.nodeName +&#x27;#&#x27;+node.id);

			return;

		};

		this._exitNode = function(node){

			&#x2F;&#x2F;check node
			if(!node) return;

			&#x2F;&#x2F;check if active
			var index = this.activeNodes.indexOf(node);
			if (index &lt; 0) return;

			&#x2F;&#x2F;remove from active nodes
			this.activeNodes.splice(index, 1);

			&#x2F;&#x2F;create timeline event object
			var e = this.buildEventObject(node);

			&#x2F;&#x2F;notify action
			this.trigger(&#x27;exit&#x27;,e);

			&#x2F;&#x2F;debug action
			this._debug(&#x27;TIMELINE !exit: &#x27;+ node.nodeName +&#x27;#&#x27;+node.id);

			return;

		};


		&#x2F;**
	     * Play timeline
	     * @return {Boolean} success or not
	     *&#x2F;
		this.play = function(){

			&#x2F;&#x2F;if is scrolling stop scroll
			if(this.is_scrolling) this.stopScroll();

			&#x2F;&#x2F;check for &quot;is_ready&quot; flag
			if (!this.is_ready) return;
			
			&#x2F;&#x2F;play in offset time become replay 
			var max = this.getDuration()*1000;
			if (this.time&gt;=max) return this.replay();

			&#x2F;&#x2F;update &quot;is_playing&quot; flag
			this.is_playing = true;
			
			&#x2F;&#x2F;start timer
			if (this.timer) this.timer.start();

			&#x2F;&#x2F;create timeline event object
			var e = this.buildEventObject(this.node);

			&#x2F;&#x2F;notify &#x27;play&#x27;
			this.trigger(&#x27;play&#x27;, e);


			return;
		};



		this.replay = function(){

			&#x2F;&#x2F;if is scrolling stop scroll
			if(this.is_scrolling) this.stopScroll();

			&#x2F;&#x2F;check for &quot;is_ready&quot; flag
			if (!this.is_ready) return;
			
			this.seekTo(0);
			this.play();

			return;
		};


		&#x2F;**
	     * Pause timeline
	     * @return {Boolean} success or not
	     *&#x2F;
		this.pause = function(){
			
			&#x2F;&#x2F;if is scrolling stop scroll
			if(this.is_scrolling) this.stopScroll();

			if(this.is_playing){

				&#x2F;&#x2F;update &quot;is_playing&quot; flag
				this.is_playing = false;
				
				&#x2F;&#x2F;stop timer
				if (this.timer) this.timer.stop();
				
				&#x2F;&#x2F;create timeline event object
				var e = this.buildEventObject(this.node);

				&#x2F;&#x2F;notify &#x27;pause&#x27;
				this.trigger(&#x27;pause&#x27;, e);

			}
			
			return;

		};
		
		&#x2F;**
	     * Toggle play&#x2F;pause timeline
	     * @return {Boolean} success or not
	     *&#x2F;
		this.toggle = function(){
		
			if (!this.is_scrolling &amp;&amp; !this.is_playing) this.play();
			else this.pause();

			return;
		
		};
		


		this.reset = function(){
		
			&#x2F;&#x2F;update &#x27;is_playing&#x27; flag
			this.is_playing = false;
			
			&#x2F;&#x2F;reset timer
			if (this.timer) this.timer.reset();

			&#x2F;&#x2F;rewind
			this.seekTo(0);
			
			&#x2F;&#x2F;notify reset
			this.trigger(&#x27;reset&#x27;);

			return;
			
		};
		


		this.seekTo = function(t){

			&#x2F;&#x2F;check for &quot;is_ready&quot; flag
			if (!this.is_ready) return;

			&#x2F;&#x2F;trying seek to start?
			t = (t)? (t&lt;=0)? 0 : t : 0;

			&#x2F;&#x2F;update time
			if (this.timer)		this.timer.setTime(t); &#x2F;&#x2F;from timer
			else				this.update(t);

			&#x2F;&#x2F;notify seek
			this.trigger(&#x27;seek&#x27;,t);

			return;
		
		};
		

		this.scroll = function(factor){

			if (!this.scroller) return;

			if(!_.isNumber(factor) || factor===0){

				&#x2F;&#x2F;set scroll factor
				this.stopScroll();

				return;

			}

			&#x2F;&#x2F;pause timeline while scrolling
			this.pause();

			&#x2F;&#x2F;update &#x27;is_scrolling&#x27; flag
			this.is_scrolling = true;

			&#x2F;&#x2F;set scroll factor
			this.scroller.factor = factor;

			&#x2F;&#x2F;sync scroller with timer
			this.scroller.time = this.timer.time;

			&#x2F;&#x2F;start scroll timer if is not already started
			if(this.scroller.paused) this.scroller.start();


			return;
		
		};

		this.stopScroll = function(){

			if (!this.scroller) return;

			&#x2F;&#x2F;set scroll factor
			this.scroller.factor = 0;

			&#x2F;&#x2F;stop scroll timer
			this.scroller.stop();

			&#x2F;&#x2F;update &#x27;is_scrolling&#x27; flag
			this.is_scrolling = false;

			return;
		
		};

		this.onscroll = function(time){

			if(this.is_playing || !this.is_scrolling){
				this.stopScroll();	return;
			}

			&#x2F;&#x2F;process parameter
			var t = (typeof time != &#x27;undefined&#x27;)? parseInt(time) : false;

			&#x2F;&#x2F;update time
			if (this.scroller)	t = this.scroller.time; &#x2F;&#x2F;update from timer

			&#x2F;&#x2F;prevent LEFT timeline offset
			if (t&lt;0){
				t = 0;
				this.stopScroll();
			}

			&#x2F;&#x2F;prevent RIGHT timeline offset
			var max = this.getDuration()*1000;
			if (t&gt;=max){
				t = max;
				this.stopScroll();
			}

			this.seekTo(t);

			return;
		
		};


		this.buildEventObject = function(target){

			var TimelineEvent = {

				&#x27;target&#x27;: target,
				&#x27;active&#x27;: this.activeNodes,
				&#x27;time&#x27;: this.time,
				&#x27;duration&#x27;:this.getDuration()

			};

			return TimelineEvent;

		};





		this.destroy = function(){

			&#x2F;&#x2F;destroy timer
			this.destroyTimer();


			&#x2F;&#x2F;notify destroy
			this.trigger(&#x27;destroy&#x27;);

			return;

		};


		this._debug = function(msg){
			if (this.debug) debug.log(msg);
		}



		this.initialize();


		return this;


	};


	&#x2F;&#x2F;expose

	window.smx.time.Timeline = SMXTimeline;


})(window.smx);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
