<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..\master\document\Document.js - The Foo API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="The Foo API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.2.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Metadata.html">Metadata</a></li>
            
                <li><a href="..&#x2F;classes/Playhead.html">Playhead</a></li>
            
                <li><a href="..&#x2F;classes/Timeline.html">Timeline</a></li>
            
                <li><a href="..&#x2F;classes/Timer.html">Timer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Node.html">Node</a></li>
            
                <li><a href="..&#x2F;modules/smx.html">smx</a></li>
            
                <li><a href="..&#x2F;modules/SMXComputedAttributes.html">SMXComputedAttributes</a></li>
            
                <li><a href="..&#x2F;modules/SMXCoreAttributes.html">SMXCoreAttributes</a></li>
            
                <li><a href="..&#x2F;modules/SMXNode.html">SMXNode</a></li>
            
                <li><a href="..&#x2F;modules/TimeAttrController
Plugin Controller for attributes namespace with &#x27;ui&#x27;.html">TimeAttrController
Plugin Controller for attributes namespace with &#x27;ui&#x27;</a></li>
            
                <li><a href="..&#x2F;modules/Track Attributes.html">Track Attributes</a></li>
            
                <li><a href="..&#x2F;modules/UIAttrController
Plugin Controller for attributes namespaced with &#x27;ui-&#x27;.html">UIAttrController
Plugin Controller for attributes namespaced with &#x27;ui-&#x27;</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ..\master\document\Document.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
*
*   @Module Node
*
*&#x2F;

(function(smx){
 


&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; PRIVATE SELECTOR ENGINE SHORTCUT
&#x2F;&#x2F; defined out of constructor, so multiple SMXDocuments will use same shortcut instance
var _SIZZLE = Sizzle;




&#x2F;**
 *  CORE ATTRIBUTES
 *
 *  Every smx node will have these attributes
 *  Default attributes values are overwritten by values in xml
 *
 *  @module SMXCoreAttributes
 *  @submodule SMXNode
 *
 *&#x2F; 

var _ATTRIBUTES = {

    &#x27;id&#x27;: &#x27;&#x27;,

    &#x27;path&#x27;: &#x27;&#x27;,

    &#x27;file&#x27;: &#x27;&#x27;,

    &#x27;type&#x27;:&#x27;smx&#x27;,

    &#x27;category&#x27;:&#x27;&#x27;

};


&#x2F;**
 *  COMPUTED ATTRIBUTES
 *
 *  Function returning calculated values from core attributes
 *
 *  @module SMXComputedAttributes
 *  @submodule SMXNode
 *
 *&#x2F; 

var _COMPUTED_ATTRIBUTES = {

    &#x2F;**
     *  @method uri
     *  Uniform Resource Identifier,&quot;url id&quot;
     *  Calculate url hash path using cummulative ids up to root
     *&#x2F; 

    &#x27;uri&#x27; : function(node){

        var hash = node.id + &#x27;&#x2F;&#x27;;
        var parent = node.parent();
        if (parent) return parent.get(&#x27;uri&#x27;) + hash;
        else        return hash;

    },


    &#x2F;**
     *  @method url
     *  Uniform Resource Locator (url path)
     *  Calculate url folder path using cummulative paths up to root
     *&#x2F;

    &#x27;url&#x27;: function(node){

        var path = node.get(&#x27;path&#x27;);

        var parent = node.parent();

        if (parent){
            if(_.isEmpty(path))
                return parent.get(&#x27;url&#x27;);
            else{

                &#x2F;&#x2F;add trail slash
                var trail = path.substr(-1);
                if (trail != &#x27;&#x2F;&#x27;) path += &#x27;&#x2F;&#x27;;

                return parent.get(&#x27;url&#x27;) + path;
            }
                
        }
        else{

            if(_.isEmpty(path)) return;

            &#x2F;&#x2F;add trail slash
            var trail = path.substr(-1);
            if (trail != &#x27;&#x2F;&#x27;) path += &#x27;&#x2F;&#x27;;

            return path;

        }

    },

    &#x2F;**
     *  @method file
     *  url of xml source file of this node
     *&#x2F;

    &#x27;file&#x27;: function(node){

        var url = &#x27;&#x27;;
        var file = node.attr(&#x27;file&#x27;);
        var parent = node.parent();

        if (_.isEmpty(file)){

            if (!parent) return;
            return parent.get(&#x27;file&#x27;);

        }
        else{

            var url = node.get(&#x27;url&#x27;);
            return url + file;
            

        }

    }

};








&#x2F;&#x2F;private namespace for SMX functions
var fn = {};



&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; ATTRIBUTE GETTERS

fn.AttributeGetters = {


    &#x2F;**
    * 
    *   Get the raw value for specified attribute key in the original xml node
    *
    *   @method raw
    *   @param key {string} The name of the attribute
    *   @return {string} resulting value
    *
    *&#x2F;

    raw:function(key){
          
        return this[0].getAttribute(key);

    },


    &#x2F;**
    * 
    *   Get the value for specified attribute key in attributes collection
    *
    *   @method attr
    *   @param key {string} The name of the attribute
    *   @return {string} resulting value
    *
    *&#x2F;

    attr:function(key){
        
        if(_.isUndefined(this.attributes[key])) return this.raw(key);
        return this.attributes[key];
    },


    &#x2F;**
    * 
    *   Get the value for specified computed attribute key
    *   If there is no computed attribute with given key will use attr method
    *
    *   @method get
    *   @param key {string} The name of the attribute
    *   @return resulting value
    *
    *&#x2F;

    get:function(key){

        &#x2F;&#x2F;key is required to be non empty string
        if(_.isEmpty(key) || !_.isString(key)) return;

        &#x2F;&#x2F;try using defined attribute getter
        var getter = _COMPUTED_ATTRIBUTES[key];

        &#x2F;&#x2F;getter exists?
        if(_.isFunction(getter)){
            return getter(this);
        }

        return this.attr(key);

    }



};






fn.CoreMethods = {

    &#x2F;&#x2F;return serialization of original XML node
    toString: function(){

        &#x2F;&#x2F;return (window.ActiveXObject)? this[0].xml : (new XMLSerializer()).serializeToString(this[0]);

        &#x2F;&#x2F;this looks better for console loggin...
        &#x2F;&#x2F;is this method being used anywhere else?..

        return this.name + &#x27;#&#x27; + this.id;

    },  

     &#x2F;&#x2F;return serialization of original XML node
    getInnerHTML: function(){

        
        var html = [];
        _.each(this.children(), function(item,index){
            html.push( (window.ActiveXObject)? item[0].xml : (new XMLSerializer()).serializeToString(item[0]) );
        });

        return html.join(&#x27;&#x27;);
        

       &#x2F;&#x2F; return this.html();

    }



};


&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; TREE NODE OPERATIONS


fn.TreeNodeMethods = {


    &#x2F;&#x2F; PARENT RELATED OPERATIONS


        &#x2F;**
        *   @method parent
        *&#x2F;
        parent: function(){
            return _SMX(this[0].parentNode);
        },     
        
        &#x2F;**
        *   @method parents
        *&#x2F;
        parents: function(){
        
            if (!this[0].parentNode) return [];
            else{
                var parent = this.parent();
                var parents = [parent];
                while (parent.parent()){
                    parent = parent.parent();
                    parents.unshift(parent);
                }
                return parents;
            }
        },

        &#x2F;**
        *   @method root
        *   Find top most parent
        *&#x2F;

        &#x27;root&#x27;: function(){

            if (this.parent()){

                &#x2F;&#x2F;get all ancestors
                var parents = this.parents();

                &#x2F;&#x2F;return top most parent node
                return parents[0];

            }
            
            return this;

        },


        &#x2F;&#x2F; EXTRA - PARENT RELATED OPERATIONS
       
        &#x2F;**
        *   @method isParentOf
        *&#x2F;
        isParentOf: function(node){
        
            &#x2F;&#x2F;validate given node (smx node required)
            if (!node.parents) return false;

            var parents = node.parents();          
            if (_.contains(parents,this)) return true;
            else return false;

        },

        &#x2F;**
        *   @method isParentOf
        *&#x2F;
        hasParent: function(node){
        
           return (this[0].parentNode)? true : false;

        },


    &#x2F;&#x2F; CHILD RELATED OPERATIONS


        &#x2F;**
        *   @method find
        *&#x2F;
        find: function(selector){

            if (!this[0].childNodes.length&gt;0) return [];
            if (!_.isString(selector) || _.isEmpty(selector)) return [];

            var query = selector || &#x27;&gt;&#x27;;

            &#x2F;&#x2F;get search context
            var nodes = [];
            try{ nodes = _SIZZLE(query,this[0]); }
            catch(e){}      

            &#x2F;&#x2F;return smx node array
            return _SMX(nodes);
        },            


        &#x2F;**
        *   @method children
        *&#x2F;
        children: function(){
            return _SMX(this[0].childNodes);
        },

        
        &#x2F;**
        *   @method first
        *&#x2F;
        first : function(){
            return _SMX(_.first(this[0].childNodes));
        },

        
        &#x2F;**
        *   @method last
        *&#x2F;
        last : function(){
            return _SMX(_.last(this[0].childNodes));
        },

        

        &#x2F;&#x2F; EXTRA - CHILD RELATED OPERATIONS 

        &#x2F;**
        *   @method childAt
        *&#x2F;
        childAt : function(index){
            return _SMX(this[0].childNodes[index]);
        },       




    &#x2F;&#x2F; SIBLING RELATED OPERATIONS


        &#x2F;**
        *   @method next
        *&#x2F;
        next : function(){
            return _SMX(this[0].nextSibling);
        },

        &#x2F;**
        *   @method previous
        *&#x2F;

        previous : function(){
            return _SMX(this[0].previousSibling);
        },
        


    &#x2F;&#x2F; FLAT TREE SIBLINGS

        &#x2F;**
        *   @method getStepBack
        *&#x2F;
        stepBack: function(){

            &#x2F;&#x2F;previousSibling?
            var _prev_sibling_node = this.previous();
            if(_prev_sibling_node) return _prev_sibling_node;
            
            &#x2F;&#x2F;parentNode?
            var _parent_node = this.parent();
            if(_parent_node) return _parent_node;
            
            &#x2F;&#x2F;nothing found...
            return;
            
        },
        
        &#x2F;**
        *   @method getStepForward
        *&#x2F;
        stepForward: function(from_last_child){
            
            &#x2F;&#x2F;in recursive calls indicate if last recursion come from lastChild of its parent
            var _from_last_child = (from_last_child)? from_last_child : false;
            
            &#x2F;&#x2F; 1. use children, trying to get deep inside node
            &#x2F;&#x2F; if (_from_last_child) means we arleady searched on childNodes and avoid it
            &#x2F;&#x2F; we avoid children when content is not smx
            if (!_from_last_child &amp;&amp; this.get(&#x27;type&#x27;)===&#x27;smx&#x27; ){
                var _first_childnode = this.first();
                return _first_childnode;
            }
                
            &#x2F;&#x2F;2. search nextSibling:
            var _next_sibling_node = this.next();
            if(_next_sibling_node) return _next_sibling_node;
            
            &#x2F;&#x2F;3. search on parentNode
            var _parent_node = this.parent();
            if(_parent_node) return _parent_node.stepForward(true);
            
            &#x2F;&#x2F;4. nothing found: return null!!
            return;
            
        }

};






&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; TIMELINE LOGIC

fn.TimelineLogic = {

                
    &#x2F;**
    *   @method isInsideTimeline
    *&#x2F;
    isInTimeline:function(){
        var is_in_timeline = false;
        var is_timeline = this.isTimeline();
        if(is_timeline){
            return false;
        }
        else{
            
            var parent = this.parent();
            while(parent &amp;&amp; !parent.isTimeline()){
                parent = parent.parent();
            }

            if(!parent) return false;
            else if(parent.isTimeline()) return true;
            else return false;

        }

    },


    &#x2F;**
    *   @method synchronize
    *&#x2F;
    synchronize: function(){

        &#x2F;&#x2F;get &#x27;timing&#x27; attribute value
        var sync = this.getTiming();

        &#x2F;&#x2F;check if node need to be sync
        if (!sync || sync == &#x27;none&#x27;){

            this.duration=0;
            this.start=0;

            &#x2F;&#x2F;do not use &#x27;sync&#x27; attribute so flag it with &#x27;is-sync&#x27;
            this[0].setAttribute(&#x27;is-sync&#x27;,&#x27;true&#x27;);

            return;   
        }


        &#x2F;&#x2F;update sync values (start, duration)
        var force_sync = true;
        var duration = this.getDuration(force_sync);
        var start = this.getStart(force_sync);

        return;
    },

                
    &#x2F;**
    *   @method getStart
    *&#x2F;
    getStart : function(force_sync){
    
        &#x2F;&#x2F;bool flag use or not local value if exists
        if (!force_sync){
            &#x2F;&#x2F;has local value?
            if(_.isNumber(this.start)) return this.start;
        }

        &#x2F;&#x2F;get it from attribute
        var start = parseInt(this[0].getAttribute(&#x27;start&#x27;));
        if(_.isNaN(start) || start&lt;0) start = 0;

        &#x2F;&#x2F;set local value
        this.start = start;

        &#x2F;&#x2F;return local value
        return start;
        
    },

                
    &#x2F;**
    *   @method getDuration
    *&#x2F;
    &#x2F;&#x2F;get duration of this node based on getDuration of child nodes
    &#x2F;&#x2F;@return: Number
    getDuration : function(force_sync){
    
        &#x2F;&#x2F;bool flag use or not local value if exists
        if (!force_sync){
            &#x2F;&#x2F;has local value?
            if(_.isNumber(this.duration)) return this.duration;
        }

        &#x2F;&#x2F;has duration attribute?
        var duration = parseInt(this[0].getAttribute(&#x27;duration&#x27;));
        if(_.isNaN(duration) || duration&lt;0) duration = NaN;

        &#x2F;&#x2F;sync start for 
        var start = this.getStart();

        &#x2F;&#x2F;try child summatory
        if (_.isNaN(duration)){
            var childs = this.children();
            childs = childs.reverse();
            if(childs.length&gt;0){
                &#x2F;&#x2F; childs will define duration using 
                &#x2F;&#x2F; the child with the highest offset+duration value
                var max = 0;
                for(var n=0; n&lt;childs.length;n++){
                    var child = childs[n];
                    var sum = child.offset() + child.getDuration(force_sync);
                    if(sum&gt;max) max = sum;
                }
                duration = max;
            }
            else if(!this.getNext() &amp;&amp; !this.getPrevious()){
                duration = 0;
            }
        }

        
        &#x2F;&#x2F;check next sibling dependencies
        if (_.isNaN(duration) &amp;&amp; this.isInTimeline()){

            &#x2F;&#x2F;get parent
            var parent = this.parent();

            if(parent &amp;&amp; _.isNumber(parent.duration)){

                &#x2F;&#x2F;get next sibling with absolute timing 
                var next = this.getNext();
                var target = null;
                while(next &amp;&amp; !target){
                    if(next.getTiming() == &#x27;absolute&#x27;)  target = next;
                    else                                next = next.getNext();
                }

                if(target){
                    if (_.isNumber(target.start) &amp;&amp; _.isNumber(this.start)){
                        duration = parseInt(next.offset()-this.start);    
                        if(_.isNaN(duration) || duration&lt;0) duration=NaN; 
                    }
                }
                else{
                    duration = parseInt(parent.duration-this.start);    
                    if(_.isNaN(duration) || duration&lt;0) duration=NaN; 
                } 
            }
            else{
                duration = NaN;
            }

        }

        if (_.isNaN(duration) &amp;&amp; !this.isInTimeline()){
            duration = 0;                    
        }

        &#x2F;&#x2F;could not determine duration? set to 0
        if(_.isNaN(duration)){
            duration = 0;
        }
        else{
            &#x2F;&#x2F;create sync flag attribute
            this[0].setAttribute(&#x27;is-sync&#x27;,&#x27;true&#x27;);
        }

        &#x2F;&#x2F;set local value
        this.duration = duration;

        &#x2F;&#x2F;return local value
        return this.duration;
        
    },

                
    &#x2F;**
    *   @method offset
    *&#x2F;
    offset : function(from){
    


        
    },

                
    &#x2F;**
    *   @method getEndTime
    *&#x2F;
    getEndTime : function(){
        return this.getStart() + this.getDuration();
    }


};




&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; META INTERFACE
&#x2F;&#x2F; &#x27;meta&#x27; attributes namespace

fn.MetaInterface = {
    
                
    &#x2F;**
    *   @method meta
    *&#x2F;
    meta: function(key){

        &#x2F;&#x2F;if exists MetaManager, use it
        if(METADATA) return METADATA.get(this.id,key);

        &#x2F;&#x2F;else look for key in attributes
        var attrs = this[0].attributes;
        var value = null;
        for(var i = 0; i &lt; attrs.length; i++) {
            var attr_name = attrs[i].name+&#x27;&#x27;;
            var attr_value = attrs[i].name+&#x27;&#x27;;
            if(attr_name.indexOf(&quot;meta-&quot;) == 0){
                attr_name = attr_name.substr(5);
                if(attr_name == key) value = attrs[i].value;
            }
            if(value) i=attrs.length;
        }

        return value;
        
    }


};




&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; TRACK INTERFACE
&#x2F;&#x2F; &#x27;track&#x27; attributes namespace

fn.TrackAttrInterface = {

                            
    &#x2F;**
    *   @method isAccesible
    *&#x2F;
    isAccesible: function(){

        var access_raw = this.track(&#x27;access&#x27;,&#x27;raw&#x27;);

        if(_.isEmpty(access_raw) || access_raw == &#x27;none&#x27;)
            return true;

        var access = parseInt(this.track(&#x27;access&#x27;));

        if(_.isNumber(access) &amp;&amp; access!=0) return false;
        else{

            var parent = this.parent();

            if(parent){
                return parent.isAccesible();        
            }
            else{
                return true;
            }
            
        }

    },

                            
    &#x2F;**
    *   @method track
    *&#x2F;
    track: function(key, format){

        &#x2F;&#x2F;if exists (TRACKING) TrackManager use it
        if(TRACKING) return TRACKING.get(this.id,key,format);

        &#x2F;&#x2F;else look for key in attributes
        var attrs = this[0].attributes;
        var value = null;
        for(var i = 0; i &lt; attrs.length; i++) {
            var attr_name = attrs[i].name+&#x27;&#x27;;
            var attr_value = attrs[i].name+&#x27;&#x27;;
            if(attr_name.indexOf(&quot;track-&quot;) == 0){
                attr_name = attr_name.substr(6);
                if(attr_name == key) value = attrs[i].value;
            }
            if(value) i = attrs.length;
        }

        return value;
        
    },

    &#x2F;**
    *   Returns true if Tracking Module is handling the given key 
    *   @method isTracking
    *   @param {String} key
    *   @return {Boolean} result
    *&#x2F;
    isTracking: function(key){

        if(!key){
        &#x2F;&#x2F;check for root track attr
            var value = this[0].getAttribute(&#x27;track&#x27;);

            if(value==&#x27;none&#x27;) return false;

            return true;

        }
        else{
        &#x2F;&#x2F;check for given key track attr

            &#x2F;&#x2F;get track-key attr value from xml source node
            var value = this[0].getAttribute(&#x27;track-&#x27;+ key);

            if (_.isUndefined(value) || _.isNull(value) || value==&#x27;none&#x27;)
                return false;

            return true;
            

        }

        return;

    }

};





&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; UI ATTRIBUTES INTERFACE
&#x2F;&#x2F; shortcut for UIAttrController.get()

fn.UIAttrInterface = {
                          
    &#x2F;**
    *   @method ui
    *&#x2F;
    ui: function(key,type){

        return smx.UIAttrController.get(this,key,type);

    }


};



&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; TIME INTERFACE
&#x2F;&#x2F; &#x27;time&#x27; attributes namespace

fn.TimeInterface = {
    
                
    &#x2F;**
    *   @method media
    *&#x2F;
    time: function(key){

        return smx.TimeAttrController.get(this,key);
    }


};




        var METADATA = null;
        var TRACKING = null;



        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; PRIVATE INDEXED NODE LISTING CACHE
        &#x2F;&#x2F; inside constructor so each document uses its own cache
        var INDEX_CACHE = {};




        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; PRIVATE SMX NODE WRAPPER

        var _SMX = function(elems){

            if (elems &amp;&amp; (_.isArray(elems) || !_.isUndefined(elems.length)) &amp;&amp; _.isUndefined(elems.nodeType)) {
                var result = [];
                for (var i=0; i&lt; elems.length; i++){
                    if (elems[i]){
                        var node = (elems[i][0])? elems[i] : _SMXNode(elems[i]);
                        if (node) result.push(node);                     
                    }
                }
                return result;
            }
            else if(elems) {
                if(elems[0])    return elems;
                else            return _SMXNode(elems);
            }
            else return;

        }; 


        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; PRIVATE SMX NODE CONSTRUCTOR FILTER

        var _SMXNode = function(xmlNode){

            var id = null;

            &#x2F;&#x2F;if(!xmlNode) return;
            &#x2F;&#x2F;if (xmlNode.nodeName == &#x27;undefined&#x27;) return;
            &#x2F;&#x2F;if (typeof xmlNode.nodeType == &#x27;undefined&#x27;) return;
            &#x2F;&#x2F;if (xmlNode.nodeType != 1) return;

            &#x2F;&#x2F;is this uncatched try an alternative to
            &#x2F;&#x2F;the 4 conditionals above?
            try{ id = xmlNode.getAttribute(&#x27;id&#x27;) } catch(e){}

            &#x2F;&#x2F;id attr is required!
            if(!id) return;

            &#x2F;&#x2F;Does already exists a node with this id?
            &#x2F;&#x2F;prevent duplicated nodes and return existing one
            if (INDEX_CACHE[id]) return INDEX_CACHE[id];

            &#x2F;&#x2F;create new SMXNode
            var node = new SMXNode(xmlNode);

            &#x2F;&#x2F;add it to nodes cache
            INDEX_CACHE[id] = node;
            
            &#x2F;&#x2F;return just created node
            return node;


        };



        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; PRIVATE SMX NODE CONSTRUCTOR

        var SMXNode = function(xmlNode){

            this[0] = xmlNode;

            &#x2F;&#x2F;console.log(&#x27;NODETYPE:&#x27; + this[0].nodeType);

            this.id = this[0].getAttribute(&#x27;id&#x27;);

            this.name = this[0].nodeName;

            this.attributes = {};

            var _this = this;

            _.each(_ATTRIBUTES,function(value, key, collection){

                _this.attributes[key] = _this[0].getAttribute(key) || value;

            });

            return this;

        };

        _.extend(SMXNode.prototype,fn.CoreMethods);
        _.extend(SMXNode.prototype,fn.TreeNodeMethods);
        _.extend(SMXNode.prototype,fn.AttributeGetters);

        _.extend(SMXNode.prototype,fn.UIAttrInterface);
        _.extend(SMXNode.prototype,fn.MetaInterface);
        _.extend(SMXNode.prototype,fn.TimeInterface);
        _.extend(SMXNode.prototype,fn.TrackAttrInterface);





    var SMXDocument = function(file, path, xml){


        if (!xml) return;

        if (!file) file = &#x27;index.xml&#x27;;
        if (!path) path = &#x27;&#x27;;








        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; INITIALIZE DOCUMENT


        &#x2F;&#x2F;get 1st node with tag body
        var body = xml.getElementsByTagName(&#x27;body&#x27;)[0];




        &#x2F;&#x2F;break parent node in body
        body = body.parentNode.removeChild(body);

        &#x2F;&#x2F;add core attributes
        body.setAttribute(&#x27;file&#x27;,file);
        body.setAttribute(&#x27;path&#x27;,path);


        &#x2F;&#x2F;create Document from body node
        var DOCUMENT = _SMX(body);

        &#x2F;&#x2F;ensure document has been wrapped, check its [0] property
        if (!DOCUMENT || !DOCUMENT[0]) return;

        &#x2F;&#x2F;add document to node indexed cache
        INDEX_CACHE[DOCUMENT.id] = DOCUMENT;


        &#x2F;&#x2F;OVERRIDES DEFAULT NODE METHODS
        &#x2F;&#x2F;WITH DOCUMENT METHODS
        _.extend(DOCUMENT,{
            getNodeById: function(id){ 
                        
                &#x2F;&#x2F;is nodes cache array?
                if(INDEX_CACHE[id]) return INDEX_CACHE[id];

                &#x2F;&#x2F;search in document
                var node = _SIZZLE(&#x27;#&#x27;+id,this[0]);
                if (node.length&gt;0) return _SMX(node[0]);

                &#x2F;&#x2F;not found
                return; 
                  
            }

        });




        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; DOCUMENT PROTOTYPES


        var PROTO = {};

        try{

            &#x2F;&#x2F;get head element
            var head = xml.getElementsByTagName(&#x27;head&#x27;)[0];

            &#x2F;&#x2F;get all &quot;prototype&quot; elements inside head
            var _prototypes_ = head.getElementsByTagName(&#x27;prototype&#x27;);

            &#x2F;&#x2F;prototypes collection to store evaluated &quot;prototype&quot; elements
            var prototypes = [];

            &#x2F;&#x2F;loop prototype elements and try to evaluate its content
            _.each(_prototypes_, function(item, index, list){

                &#x2F;&#x2F;try evalualting text content and add it to prototypes collection
                try{
                    prototypes.push( eval( &#x27;(&#x27;+ item.firstChild.nodeValue +&#x27;)&#x27; ) );
                    LOG(&#x27;OK EVALUATING PROTOTYPES FROM &quot;&#x27;+ item.getAttribute(&#x27;file&#x27;) +&#x27;&quot;&#x27;);
                }
                catch(e){
                    LOG(&#x27;ERROR EVALUATING PROTOTYPES FROM &quot;&#x27;+ item.getAttribute(&#x27;file&#x27;) +&#x27;&quot;&#x27;);
                }

            });

            &#x2F;&#x2F;loop prototypes collection
            _.each(prototypes, function(item, index, collection){

                &#x2F;&#x2F;loop prototype rules and propagate it into root PROTO object
                _.each(item, function(value, key, list){

                    &#x2F;&#x2F;if key rule exists extend it
                    if(PROTO[key]) _.extend(PROTO[key], value);
                    &#x2F;&#x2F;else create key rule
                    else PROTO[key] = value;

                });

            });

            if (prototypes.length === 0){
                LOG(&#x27;DOCUMENT HAS NO PROTOTYPES&#x27;);
            }
            else{
                LOG(&#x27;DOCUMENT PROTOTYPES PROCESSING COMPLETED&#x27;);   
            }

        }
        catch(e){

            LOG(&#x27;ERROR PROCESSING DOCUMENT PROTOTYPES&#x27;);

        }

                    
        DOCUMENT.proto = PROTO;



        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F;
        &#x2F;&#x2F; APPLY PROTOTYPES
        &#x2F;&#x2F;
        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;


        var getProtoAttributes = function(selector){

            &#x2F;&#x2F;get proto object
            var proto = PROTO[selector];

            &#x2F;&#x2F;proto does not exists
            if(!proto) return;

            &#x2F;&#x2F;create new object extended from proto
            var attrs = _.extend({}, proto);

            &#x2F;&#x2F;check if &#x27;ext&#x27; attribute exists
            &#x2F;&#x2F;&#x27;ext&#x27; is the id of the prototype of which is extended
            if (!_.isUndefined(attrs[&#x27;ext&#x27;])){

                &#x2F;&#x2F;get ext value
                var ext = attrs.ext;

                &#x2F;&#x2F;delete ext attr, so it does not apply to nodes
                &#x2F;&#x2F;delete attrs.ext; equals to undefined is faster than delete
                attrs.ext = undefined;

                &#x2F;&#x2F;get ext proto attributes
                var ext_attrs = getProtoAttributes(ext);

                &#x2F;&#x2F;if ext proto attrs recived, extend attrs with ext attrs
                if (ext_attrs) attrs = _.extend(attrs,ext_attrs);

            }

            return attrs;

        }


        var applyProtoAttributes = function(node,attrs){

            _.each(attrs, function(value,key,list){

                &#x2F;&#x2F;string values is required
                if (!_.isString(value)) return;

                &#x2F;&#x2F;if value starts with &#x27;!&#x27; is taken as important
                &#x2F;&#x2F;important values will overwrite node attribute values
                if (value.indexOf(&#x27;!&#x27;)===0){

                    &#x2F;&#x2F;remove &#x27;!&#x27; so it does not apply to node attributes
                    value = value.substr(1);

                    &#x2F;&#x2F;apply attr value into node
                    node[0].setAttribute(key,value);     

                }
                else{

                    &#x2F;&#x2F;value is taken as default
                    &#x2F;&#x2F;do not apply if node already has key attribute
                    if (!node[0].getAttribute(key))
                        node[0].setAttribute(key,value);

                }



            });


        }


        _.each(PROTO, function(value, key, list){

            &#x2F;&#x2F;get matching nodes
            var nodes = DOCUMENT.find(key);

            &#x2F;&#x2F;check document apart, find method does not include document itself for searches
            if (_SIZZLE.matchesSelector(DOCUMENT[0],key)) nodes.unshift(DOCUMENT);

            &#x2F;&#x2F;no matching nodes?
            if (nodes.length===0) return;

            &#x2F;&#x2F;get proto attrs
            var attrs = getProtoAttributes(key);

            &#x2F;&#x2F;apply attrs to each matching node
            _.each(nodes, function(item, index){

                applyProtoAttributes(item,attrs);

            });


        });






        &#x2F;*

        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F;
        &#x2F;&#x2F; SYNCHRONIZE DOCUMENT
        &#x2F;&#x2F;
        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

        &#x2F;&#x2F;this call should synchronize whole document
        &#x2F;&#x2F;by synchronize we are meaning the initialization
        &#x2F;&#x2F;of &#x27;start&#x27; and &#x27;duration&#x27; attributes of a node

        &#x2F;&#x2F;max loop recursion
        var max = 25; var n =0;

        &#x2F;&#x2F;get all unsync nodes
        &#x2F;&#x2F;at this point all nodes should be unsync
        var unsync = DOCUMENT.children(&#x27;* :not([is-sync])&#x27;);

        &#x2F;&#x2F;add document itself to unsync nodes
        unsync.unshift(DOCUMENT);

        &#x2F;&#x2F;count nodes for sync
        var total = unsync.length;

        console.log(&#x27;SYNC &#x27;+ total);

        while( n&lt;max &amp;&amp; unsync.length&gt;0 ){

            &#x2F;&#x2F;reverse nodes array
            &#x2F;&#x2F;sync from end to begin and from inside to outside
            unsync = unsync.reverse();

            &#x2F;&#x2F;loop call &#x27;synchronize&#x27;
            for (var i=0;i&lt;unsync.length;i++){
                unsync[i].synchronize();
            }

            &#x2F;&#x2F;get nodes that still unsync
            unsync = DOCUMENT.children(&#x27;* :not([is-sync])&#x27;);

            console.log(&#x27;SYNC (&#x27;+(total-unsync.length) +&#x27;&#x2F;&#x27;+ total+&#x27;)&#x27;);

            n++;
        }

        if(unsync.length&gt;0)     console.log(&#x27;SYNCHRONIZE FAILED (&#x27;+(total-unsync.length) +&#x27;&#x2F;&#x27;+ total+&#x27;)&#x27;);
        else                    console.log(&#x27;SYNCHRONIZED &#x27;+(total-unsync.length));

        
        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

        *&#x2F;


        &#x2F;&#x2F; SETUP PLAYHEAD
        DOCUMENT.playhead = new smx.Playhead(DOCUMENT);


        &#x2F;&#x2F; SETUP METADATA
        METADATA = new smx.meta.MetaManager(DOCUMENT);
        DOCUMENT.metadata = METADATA;


        &#x2F;&#x2F; SETUP TRACKING
        TRACKING = new smx.tracking.TrackManager(DOCUMENT);
        DOCUMENT.tracking = TRACKING;


        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

        return DOCUMENT;

    };

    &#x2F;&#x2F;expose

    smx.Document = SMXDocument;



})(window.smx);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
