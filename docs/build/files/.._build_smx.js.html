<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..\build\smx.js - The Foo API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="The Foo API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.2.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Metadata.html">Metadata</a></li>
            
                <li><a href="..&#x2F;classes/Playhead.html">Playhead</a></li>
            
                <li><a href="..&#x2F;classes/Timeline.html">Timeline</a></li>
            
                <li><a href="..&#x2F;classes/Timer.html">Timer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Node.html">Node</a></li>
            
                <li><a href="..&#x2F;modules/smx.html">smx</a></li>
            
                <li><a href="..&#x2F;modules/SMXComputedAttributes.html">SMXComputedAttributes</a></li>
            
                <li><a href="..&#x2F;modules/SMXCoreAttributes.html">SMXCoreAttributes</a></li>
            
                <li><a href="..&#x2F;modules/SMXNode.html">SMXNode</a></li>
            
                <li><a href="..&#x2F;modules/TimeAttrController
Plugin Controller for attributes namespace with &#x27;ui&#x27;.html">TimeAttrController
Plugin Controller for attributes namespace with &#x27;ui&#x27;</a></li>
            
                <li><a href="..&#x2F;modules/Track Attributes.html">Track Attributes</a></li>
            
                <li><a href="..&#x2F;modules/UIAttrController
Plugin Controller for attributes namespaced with &#x27;ui-&#x27;.html">UIAttrController
Plugin Controller for attributes namespaced with &#x27;ui-&#x27;</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ..\build\smx.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
*	SMX Synchronized Multimedia XML
*
*	@module smx
*
*&#x2F;



(function(window){


	var smx = {};

	&#x2F;* software version: major.minor.path *&#x2F;
	smx.version = &#x27;0.7.6&#x27;;


	&#x2F;* GLOBAL STATUS CODES *&#x2F;
	smx.STATUS_CODE = {};
	smx.STATUS_CODE.UNDEFINED	= -1;
	smx.STATUS_CODE.NOTSTARTED	= 0;
	smx.STATUS_CODE.ERROR		= 1;
	smx.STATUS_CODE.LOADED		= 2;
	smx.STATUS_CODE.BUSY		= 3;
	smx.STATUS_CODE.READY		= 4;


	&#x2F;&#x2F;expose

	window.smx = smx;


})(window);


	;&#x2F;**
 * SMX DOCUMENT COMPILER
 * Load smx xml document, search and load recursively &quot;include&quot; nodes
 *&#x2F;

(function(window,_,$,smx){



	&#x2F;**
	 *	Element definitions are flexible, but there some reserved tagnames
	 *	&lt;smx&gt;		root of any smx document
	 *	&lt;head&gt;		smx definitions container
	 *	&lt;body&gt;		smx content container
	 *	&lt;include&gt;	include another smx document
	 *	
	 *&#x2F;

	var SMX_ELEMENTS = {

		&#x27;smx&#x27;:{},

		&#x27;head&#x27;:{},

		&#x27;body&#x27;:{},

		&#x27;proto&#x27;:{},

		&#x27;include&#x27;:{}

	};

	var SMX_ATTRIBUTES = {

		&#x27;id&#x27;:{},

		&#x27;path&#x27;:{}, &#x27;file&#x27;:{}, &#x27;src&#x27;:{},	

		&#x27;meta&#x27;:{}, &#x27;track&#x27;:{}, &#x27;ui&#x27;:{}

	};



 	var DocumentCompiler = function(options){


		&#x2F;&#x2F;extended with custom events
		_.extend(this, Backbone.Events);

		&#x2F;&#x2F;define default options
		this.defaults = {
			&quot;path&quot; : &quot;&quot;,
			&quot;directoryIndex&quot; : &quot;index.xml&quot;,
			&quot;compiled&quot; : false
		};

		&#x2F;&#x2F; process options
		this.options = _.defaults(options || {}, this.defaults);

		&#x2F;&#x2F; XML Dcoument Object
		this.XML = null;

		&#x2F;&#x2F; TEXT XML code String (compressed &amp; factorized)
		this.TEXT = null;

		&#x2F;&#x2F; Ajax controller for file requests
		this.AjaxRequest = null;

		this.loadDocument = function(path){

			this.options.path = path || &#x27;&#x27;;


			if (this.options.compiled){
				var url = (this.options.path!=&#x27;&#x27;)? this.options.path+&#x27;&#x2F;&#x27;+ &#x27;index.txt&#x27; : &#x27;index.txt&#x27;;
				this.loadCompiledFile( url );	
			}
			else{
				var url = (this.options.path!=&#x27;&#x27;)? this.options.path+&#x27;&#x2F;&#x27;+ this.options.directoryIndex : &#x27;&#x27;+this.options.directoryIndex;
				this.loadXMLFile( url );				
			}

			
			return;

		};

		this.loadXMLFile = function(file){
		
			&#x2F;&#x2F;filter params
			if(!file) this.onLoadXMLError(&#x27;ERROR: loadXMLFile -&gt; no file&#x27;);

			console.log(&#x27;@ LOADING XML &#x27;+ file +&#x27;&#x27;);
			
			this.AjaxRequest = $.ajax({
				&#x27;type&#x27;: &quot;GET&quot;,
				&#x27;url&#x27;: file,
				&#x27;dataType&#x27;: &quot;xml&quot;,
				&#x27;cache&#x27;: false,
				&#x27;data&#x27;:&#x27;&#x27;,
				&#x27;success&#x27;: _.bind(this.onLoadXMLSuccess, this),
				&#x27;error&#x27;: _.bind(this.onLoadXMLError, this)
	 		});

	 		this.AjaxRequest.url = file;

	 		return;

		};

		this.onLoadXMLSuccess = function(xml){

			var url = this.AjaxRequest.url;
			&#x2F;&#x2F;debug.log(&#x27;OK &quot;&#x27;+ url +&#x27;&quot; loaded!&#x27;);

			&#x2F;&#x2F;detect if already exist xml root node
			var is_root = (!this.XML)? true : false;

			if (is_root){

				&#x2F;&#x2F;set xml root node
				this.XML = $(xml)[0];	

			}
			else{

				&#x2F;&#x2F;if is not root -&gt; is an include
				&#x2F;&#x2F;replaces 1st &lt;include&gt; found with just loaded xml

				var includes = $(this.XML).find(&#x27;include&#x27;);

				&#x2F;&#x2F;get &lt;include&gt; node
				var old_node = includes[0];

				&#x2F;&#x2F;get just loaded node
				var new_node = xml.lastChild;

				&#x2F;&#x2F;copy old_node attributes into new_node 
				$(new_node).attr(&#x27;id&#x27;, $(old_node).attr(&#x27;id&#x27;));

				&#x2F;&#x2F;create &#x27;path&#x27; and &#x27;file&#x27; from &#x27;src&#x27;
				var src_attr = $(old_node).attr(&#x27;src&#x27;);
				if (src_attr){

					var path_attr = &#x27;&#x27;;
					var file_attr = &#x27;&#x27;;

					var src_parts = src_attr.split(&#x27;&#x2F;&#x27;);
					if(src_parts.length&gt;0){
						if(src_parts[src_parts.length-1].indexOf(&#x27;.xml&#x27;)){
							file_attr = src_parts[src_parts.length-1];
							src_parts.pop();
							path_attr = src_parts.join(&#x27;&#x2F;&#x27;);
						}
						else{
							path_attr = src_attr;
						}
					}
							
					&#x2F;&#x2F;set inlcuded node core attributes
					if(!_.isEmpty(path_attr)) $(new_node).attr(&#x27;path&#x27;, path_attr);
					if(!_.isEmpty(file_attr)) $(new_node).attr(&#x27;file&#x27;, file_attr);

				}

				&#x2F;&#x2F;copy old node attributes into new node
				var old_attributes = old_node.attributes;
				var no_copy_attributes = [&#x27;id&#x27;,&#x27;src&#x27;,&#x27;path&#x27;,&#x27;file&#x27;];
				for (var i=0; i&lt; old_attributes.length; i++){
					var attr_name = old_attributes[i].name;
					var attr_value = old_attributes[i].value;

					if(!_.contains(no_copy_attributes, attr_name)){
						var attr = $(new_node).attr(attr_name);
						if(typeof attr !== &#x27;undefined&#x27; &amp;&amp; attr !== false){
							&#x2F;&#x2F;new node has its own attribute value
						}
						else{
							&#x2F;&#x2F;copy attribute 
							$(new_node).attr(attr_name, attr_value);	
						}
						
					}
				}				


				&#x2F;&#x2F;replace old node with new node
				$(old_node).replaceWith(new_node);

			}


			&#x2F;&#x2F;check for &lt;include&gt;?
			var includes = $(this.XML).find(&#x27;include&#x27;);
			if(includes.length&gt;0){

				var include_path = $(includes[0]).attr(&#x27;src&#x27;) || &#x27;&#x27;;
				var ref = includes[0];
				while (ref.parentNode){
					var parent = ref.parentNode;
					if ($(parent).attr(&#x27;path&#x27;)) include_path = $(parent).attr(&#x27;path&#x27;) + &#x27;&#x2F;&#x27; + include_path;
					ref = parent;
				}

				if (include_path &amp;&amp; include_path!= &#x27;&#x27;) this.loadXMLFile(this.options.path+&#x27;&#x2F;&#x27;+include_path);

				return;
			}

			&#x2F;&#x2F; get server date for date synchronized behaviors
			&#x2F;&#x2F; client date can be hacked easily
			&#x2F;&#x2F; rely only on server date instead client date
			&#x2F;&#x2F; this.serverDate = arguments[2].getResponseHeader(&#x27;date&#x27;);


			this.onLoadXMLComplete();

			return;

		};

		this.onLoadXMLError = function(e){

			var url = this.AjaxRequest.url;
			&#x2F;&#x2F;debug.log(&#x27;ERROR loading &quot;&#x27;+ url +&#x27;&quot;&#x27;);

			this.trigger(&#x27;error&#x27;);
		};

		this.onLoadXMLComplete = function(){

			try{ this.factorizeXML() }
			catch(e){
				LOG(&#x27;COMPILER: ERROR! factorizeXML failed!&#x27;)
			}

			try{ this.compressXML() }
			catch(e){
				LOG(&#x27;COMPILER: ERROR! compressXML failed!&#x27;)
			}
			

			this.trigger(&#x27;complete&#x27;, this.XML);

		};



		this.loadCompiledFile = function(file){
		
			&#x2F;&#x2F;filter params
			if(!file) this.onLoadXMLError(&#x27;ERROR: loadXMLFile -&gt; no file&#x27;);

			console.log(&#x27;@ LOADING COMPILED &#x27;+ file +&#x27;&#x27;);
			
			this.AjaxRequest = $.ajax({
				&#x27;type&#x27;: &quot;GET&quot;,
				&#x27;url&#x27;: file,
				&#x27;dataType&#x27;: &quot;text&quot;,
				&#x27;async&#x27;: false,
				&#x27;cache&#x27;: false,
				&#x27;data&#x27;:&#x27;&#x27;,
				&#x27;success&#x27;: _.bind(this.onLoadCompiledSuccess, this),
				&#x27;error&#x27;: _.bind(this.onLoadCompiledError, this)
	 		});

	 		this.AjaxRequest.url = file;

	 		return;

		};

		this.onLoadCompiledSuccess = function(text){

			this.TEXT = this.decryptText(text);

			&#x2F;&#x2F;set xml root node
			this.XML = this.str2XML(this.TEXT);

			this.trigger(&#x27;complete&#x27;, this.XML);

			return;

		};

		this.onLoadCompiledError = function(e){

			var url = this.AjaxRequest.url;
			&#x2F;&#x2F;debug.log(&#x27;ERROR loading &quot;&#x27;+ url +&#x27;&quot;&#x27;);

			this.trigger(&#x27;error&#x27;);
		};



		this.factorizeXML = function(){

	
			&#x2F;&#x2F;remove undesired content, xml comments and others
			$(this.XML).find(&#x27;*&#x27;).each(function(index,item) {
			    if(item.nodeType != 1) {
			        $(item).remove();
			    }
			});
			

			&#x2F;&#x2F;ensure all xml nodes have an id attribute
			&#x2F;&#x2F;var getUTId = function(){ var time = new Date().getTime(); while (time == new Date().getTime()); return new Date().getTime()+&#x27;&#x27;; };
			var nid = 0; var getUTId = function(){ nid=nid+1; return &#x27;&#x27;+nid };
			$(this.XML).find(&#x27;:not([id])&#x27;).each(_.bind(function(index,item){
				$(item).attr(&#x27;id&#x27;,getUTId());
			},this));


			&#x2F;&#x2F;check for duplicated ids
			$(this.XML).find(&#x27;[id]&#x27;).each(_.bind(function(index,item){
				var id = $(item).attr(&#x27;id&#x27;);
				var ids = $(this.XML).find(&#x27;[id=&quot;&#x27;+id+&#x27;&quot;]&#x27;);
				if(ids.length&gt;1 &amp;&amp; ids[0]==this)
				console.warn(&#x27;Multiple IDs #&#x27;+id);
			},this));




			&#x2F;&#x2F;normalize all attributes refering time values
			var parseTime = function(value, default_value){

				if ( !value || !_.isString(value) || value == &#x27;auto&#x27; || value&lt;0 )
					return default_value;

				var important = false;
				if(value.indexOf(&#x27;!&#x27;)==0){
					important = true;
					value = value.substr(1);
				}

				if (value.indexOf(&#x27;:&#x27;)&gt;=0){
					
					var sum = 0;
					var factor = 1;
					var values=(value).split(&#x27;:&#x27;);
					values.reverse();
					for (var i = 0; i&lt;values.length; i++){
						sum += parseFloat(values[i])*factor;
						factor = factor*60;
					}

					if (important) 	return &#x27;!&#x27;+sum;
					else 			return sum;
				}

				if (important) 	return &#x27;!&#x27;+parseFloat(value);
				else 			return parseFloat(value);

			};

			$(this.XML).find(&#x27;[duration],[start],[offset]&#x27;).each(_.bind(function(index,item){

				var duration = $(item).attr(&#x27;duration&#x27;);
				var start = $(item).attr(&#x27;start&#x27;);
				var offset = $(item).attr(&#x27;offset&#x27;);

				if (duration) $(item).attr(&#x27;duration&#x27;,parseTime(duration,&#x27;auto&#x27;));
				if (start) $(item).attr(&#x27;start&#x27;,parseTime(start,&#x27;auto&#x27;));
				if (offset) $(item).attr(&#x27;offset&#x27;,parseTime(offset,0));

			},this));


			return;
		};




		this.compressXML = function(){


			&#x2F;&#x2F;get serialized xml code
			var code = this.XML2str(this.XML);


			&#x2F;&#x2F;remove multiple whitespaces
			var min = code.replace(&#x2F;\s+&#x2F;gm,&quot; &quot;);


			&#x2F;&#x2F;remove newline &#x2F; carriage return
			min = min.replace(&#x2F;\n&#x2F;g, &quot;&quot;);

			&#x2F;&#x2F;remove whitespace (space and tabs) before tags
			min = min.replace(&#x2F;[\t ]+\&lt;&#x2F;gm, &quot;&lt;&quot;);

			&#x2F;&#x2F;remove whitespace between tags
			min = min.replace(&#x2F;\&gt;[\t ]+\&lt;&#x2F;gm, &quot;&gt;&lt;&quot;);

			&#x2F;&#x2F;remove whitespace after tags
			min = min.replace(&#x2F;\&gt;[\t ]+$&#x2F;gm, &quot;&gt;&quot;);


			&#x2F;&#x2F;remove XML comments
			min = min.replace(&#x2F;&lt;!--(.*?)--&gt;&#x2F;gm, &quot;&quot;);

			&#x2F;&#x2F;update compiler TEXT result
			this.TEXT = min;



			&#x2F;&#x2F;update compiler xml result
			this.XML = this.str2XML(min);

			return;
		};


		this.XML2str = function(XML){

			var str = &#x27;&#x27;;

			if (window.ActiveXObject){

				if (XML.xml) str = XML.xml;
				else{
					str = (new XMLSerializer()).serializeToString(XML);
				}

			}
			else{
				str = (new XMLSerializer()).serializeToString(XML);
			}





			&#x2F;*
			if(window.ActiveXObject){
				alert(&#x27;window.ActiveXObject: &#x27; + window.ActiveXObject)
			}
			alert(&#x27;XML.xml: &#x27; +XML.xml);
			*&#x2F;

			&#x2F;&#x2F;alert(str);

			return str;	

		};

		this.str2XML = function(str){

			var XML = null;

            if (window.ActiveXObject){

              var XML = new ActiveXObject(&#x27;Microsoft.XMLDOM&#x27;);
              XML.async = &#x27;false&#x27;;
              XML.loadXML(str);

            } else {

              var parser = new DOMParser();
              var XML = parser.parseFromString(str,&#x27;text&#x2F;xml&#x27;);

            }

            return XML;
		};


		&#x2F;*
			raw copy from:
			http:&#x2F;&#x2F;davidwalsh.name&#x2F;convert-xml-json

		*&#x2F;
		this.xmlToJson = function(xml) {
			
			&#x2F;&#x2F; Create the return object
			var obj = {};

			if (xml.nodeType == 1) { &#x2F;&#x2F; element
				&#x2F;&#x2F; do attributes
				if (xml.attributes.length &gt; 0) {
				obj[&quot;@attributes&quot;] = {};
					for (var j = 0; j &lt; xml.attributes.length; j++) {
						var attribute = xml.attributes.item(j);
						obj[&quot;@attributes&quot;][attribute.nodeName] = attribute.nodeValue;
					}
				}
			} else if (xml.nodeType == 3) { &#x2F;&#x2F; text
				obj = xml.nodeValue;
			}

			&#x2F;&#x2F; do children
			if (xml.hasChildNodes()) {
				for(var i = 0; i &lt; xml.childNodes.length; i++) {
					var item = xml.childNodes.item(i);
					var nodeName = item.nodeName;
					if (typeof(obj[nodeName]) == &quot;undefined&quot;) {
						obj[nodeName] = this.xmlToJson(item);
					} else {
						if (typeof(obj[nodeName].push) == &quot;undefined&quot;) {
							var old = obj[nodeName];
							obj[nodeName] = [];
							obj[nodeName].push(old);
						}
						obj[nodeName].push(this.xmlToJson(item));
					}
				}
			}
			return obj;

		};


		this.encryptText = function(TEXT){

			if (!_.isString(TEXT)) return;

			var encrypted = &#x27;&#x27;;

			for (var c=0; c&lt; TEXT.length;c++){
				&#x2F;&#x2F;var offset = (c%99);
				var offset = 1;
				encrypted+= String.fromCharCode(TEXT.charCodeAt(c)+offset);
			}

			return encrypted;
		};

		this.decryptText = function(TEXT){

			if (!_.isString(TEXT)) return;

			var decrypted = &#x27;&#x27;;

			for (var c=0; c&lt; TEXT.length;c++){
				&#x2F;&#x2F;var offset = (c%99);
				var offset = 1;
				decrypted+= String.fromCharCode(TEXT.charCodeAt(c)-offset);
			}

			return decrypted;
		};

		return this;
		
	
	};


	&#x2F;&#x2F;expose
	smx.Compiler = DocumentCompiler;




})(window,_,$,smx);;
(function(smx) {

	&#x2F;&#x2F;expose
	smx.time = {};

})(window.smx);;&#x2F;**
* Timer Controller
*
* @class Timer
* @constructor
*&#x2F;

(function(){


	var SMXTimer = function(){

		_.extend(this, Backbone.Events);

		&#x2F;&#x2F;interval time
		this.fps = 16; &#x2F;&#x2F; [ 16 | 24 | 32 | 48 | 64 ... ] higher value may push performance limits (not recommended)
		
		&#x2F;&#x2F;timer engine
		this.engine = null;
		
		&#x2F;&#x2F;external engine
		this.extEngines = [];
		
		&#x2F;&#x2F;time counter
		this.time = 0;
		
		&#x2F;&#x2F;time flag
		this.time_flag = null;
		
		&#x2F;&#x2F;loop enabled or not
		this.paused = true;

		&#x2F;&#x2F;requestAnimationFrame?
		this.rAF = false;

		&#x2F;&#x2F;speed
		this.factor = 1;

		this.start = function(){
		
			&#x2F;&#x2F;prevents duplicated runs
			if (this.engine) this.stop();
			
			&#x2F;&#x2F;set time_flag
			this.time_flag = new Date().getTime();
			
			&#x2F;&#x2F;activate loop
			this.paused = false;
			
			&#x2F;&#x2F;set timeout
			if (this.rAF) this.engine = window.requestAnimationFrame( _.bind(this.update,this) );
			else this.engine = setTimeout( _.bind(this.update,this), 1000&#x2F;this.fps );

		};
		
		
		this.plugExtEngine = function(engineId, engine_callback){
		
			&#x2F;&#x2F;engine_callback must be a function returning current time in ms
			this.extEngines.unshift({&#x27;id&#x27;: engineId, &#x27;callback&#x27;: engine_callback});

			return;
		
		};
		
		this.unplugExtEngine = function(engineId){
		
			var found_at_index = -1;
			for (var i=0; i&lt; this.extEngines.length; i++){
				if(this.extEngines[i].id==engineId){
					this.extEngines[i] = null;
					found_at_index = i;
				}
			}
			if(found_at_index&gt;=0){
				this.extEngines.splice(found_at_index,1);
			}

			if (this.extEngines.length==0 &amp;&amp; !this.paused) this.start();
			
			return;
		
		};
		
		this.update = function(time,timerId){
		
			&#x2F;&#x2F;using internal engine &#x27;update&#x27; recives 0 parameters
			&#x2F;&#x2F;and use new Date().getTime() to calculate time ellapsed since last update

			&#x2F;&#x2F;external engines callback must recive 2 param
			&#x2F;&#x2F;time: target time
			&#x2F;&#x2F;timerId: id of a registered external engine
			&#x2F;&#x2F;only registered engines via &#x27;plugExtEngine&#x27; method take effect
			&#x2F;&#x2F;if timerId is not found time param will be ignored and will exit silently

			if (typeof time != &#x27;undefined&#x27; &amp;&amp; typeof timerId != &#x27;undefined&#x27;){

				&#x2F;&#x2F;multiple external engines are not supported
				&#x2F;&#x2F;so, always take only the first extEngine and ignore the others
				if (this.extEngines[0].id == timerId){

					&#x2F;&#x2F;update using param provided by external engine
					this.time = time;
					&#x2F;&#x2F;debug.log(&#x27;TIMER - timer:&#x27;+ parseInt(this.time) +&#x27; from externalEngine:&#x27;+this.extEngines[0].id);
				
					&#x2F;&#x2F;notify update and exit
					this.trigger(&#x27;update&#x27;);
					return;

				}
				else{

					&#x2F;&#x2F;timerId not found, exit silently
					return;
				}

			}

			&#x2F;&#x2F;calculate time ellapsed since last update
			var time_now = new Date().getTime();
			var time_offset = (this.time_flag!=null)? time_now - this.time_flag : 0;
			this.time_flag = time_now;


			&#x2F;&#x2F;calculate real fps
			&#x2F;&#x2F;var fps = 1000&#x2F;time_offset;

			&#x2F;&#x2F;update time
			this.time+=time_offset*this.factor;	
			&#x2F;&#x2F;debug.log(&#x27;TIMER - timer:&#x27;+ parseInt(this.time) +&#x27; from internal engine&#x27;);


			&#x2F;&#x2F;set timeout to next frame
			if (!this.paused &amp;&amp; this.extEngines.length==0){
				if (this.rAF) this.engine = window.requestAnimationFrame( _.bind(this.update,this) );
				else this.engine = setTimeout( _.bind(this.update,this), 1000&#x2F;this.fps );
			}

			&#x2F;&#x2F;notify update and exit
			this.trigger(&#x27;update&#x27;);

			return;

		};
		
		
		this.setTime = function(t){
		
			this.time = t;
			
			&#x2F;&#x2F;notify update
			this.trigger(&#x27;update&#x27;);


		};

		this.stop = function(){
		
			&#x2F;&#x2F;reset timeout
			if (this.engine){
				if (this.rAF) window.cancelAnimationFrame(this.engine);
				else clearTimeout(this.engine);
				this.engine = null;
			}
			
			&#x2F;&#x2F;reset time_flag
			this.time_flag = null;
			
			&#x2F;&#x2F;deactivate update loop
			this.paused = true;
			
			return;

		};
		
		this.reset = function(){
		
			this.stop();
			this.time = 0;

		};
		
		this.destroy = function(){

			&#x2F;&#x2F;kill loop process
			this.stop();

			&#x2F;&#x2F;clear extEngines
			this.extEngines = [];

			return;
		};
		

		return this;
		
	};

	&#x2F;&#x2F;expose 

	window.smx.time.Timer = SMXTimer;

})(window.smx);;&#x2F;**

Timeline Controller, Provides basic time handling

@class Timeline
@constructor
@uses Timer
@param node {Node} Node from which to create the timeline, required node using timeline

*&#x2F;

&#x2F;*

	· time
	. is_playing
	. is_ready
	· time2s[]
	. keyframes{}

	+ play
	+ replay
	+ next
	+ previous
	+ goTo

	! update
	! play
	! pause
	! seek
	! timemark


*&#x2F;

(function(smx){


&#x2F;**



*&#x2F;

	var SMXTimeline = function(node){

		if(!node) return;

		&#x2F;&#x2F;extends with events
		_.extend(this, Backbone.Events);


		&#x2F;**
		
		Node from which the timeline is created
		@property node {Node}

		*&#x2F;

		&#x2F;&#x2F;define node ref
		this.node = node;

		&#x2F;**
		
		Current time
		@property time {Number}
		@default 0

		*&#x2F;

		&#x2F;&#x2F;current time
		this.time = 0;

		&#x2F;&#x2F;time cache
		this.time2 = -2;
		

		&#x2F;&#x2F;TIMER ENGINES

		&#x2F;**
		
		Timer engine used for time tic tacking
		@property timer {Object}

		*&#x2F;

		&#x2F;&#x2F;used for playing
		this.timer = null;

		&#x2F;&#x2F;used for scrolling
		this.scroller = null;


		&#x2F;&#x2F;STATUS FLAGS

		this.is_playing = false;

		this.is_scrolling = false;

		this.is_ready = true;


		&#x2F;&#x2F;TIMELINE SELECTION
		&#x2F;&#x2F;Array containing all selected nodes
		this.activeNodes = [];


		&#x2F;&#x2F;KEYFRAMES
		this.keyFrames = {};


		this.debug = false;


		this.initialize = function(){

			this.createTimer();

			this.updateKeyFrames();

			return;
		};


		this.createTimer= function(){
		
			&#x2F;&#x2F;create timer engine
			this.timer = new smx.time.Timer();
			
			&#x2F;&#x2F;create observer for timer &#x27;update&#x27; event
			this.timer.on(&#x27;update&#x27;, this.update, this);

			&#x2F;&#x2F;create timer engine
			this.scroller = new smx.time.Timer();
			&#x2F;&#x2F;this.scroller.fps = 10;
			
			&#x2F;&#x2F;create observer for timer &#x27;update&#x27; event
			this.scroller.on(&#x27;update&#x27;, this.onscroll, this);

			return;
			
		};

		this.destroyTimer= function(){
		
			if (!this.timer) return;

			this.timer.off(&#x27;update&#x27;, this.update);
			
			this.timer.destroy();

			this.timer = null;

			if (!this.scroller) return;

			this.scroller.off(&#x27;update&#x27;, this.onscroll);
			
			this.scroller.destroy();

			this.scroller = null;

			return;
			
		};


		this.plugExtTimer = function(name, callback){

			if (!this.timer || !name || !callback) return;

			this.timer.plugExtEngine(name, callback);

			return;

		};


		this.unplugExtTimer = function(name){

			if (!this.timer || !name) return;

			this.timer.unplugExtEngine(name);

			return;

		};


		this.getDuration = function(){

			return this.node.getDuration();

		};


		this.updateKeyFrames = function(){
			
			&#x2F;&#x2F;create&#x2F;reset empty object
			this.keyFrames = {};


			&#x2F;&#x2F;get timemarks
			var childs = this.node.find(&#x27;*&#x27;);
			
			for (var i=0; i&lt;childs.length;i++){
			
				&#x2F;&#x2F;get tm
				var child =  childs[i];
				

				&#x2F;&#x2F;get resulting times
				var _startTime = child.offset(this.node);
				var _finishTime = child.offset(this.node) + child.getDuration();
				

				&#x2F;&#x2F;create activation keyframe at start time
				this._addKeyFrame(_startTime, child.id, 1);
				
				&#x2F;&#x2F;create deactivation keyframe at finish time
				this._addKeyFrame(_finishTime, child.id, 0);
				

			}


			this._sortKeyFrames();

			return;
				
		};

		this._addKeyFrame = function(t,id,action){

			&#x2F;&#x2F;if keyframe[t] does not exist create keyframe array
			if (!this.keyFrames[t+&#x27;&#x27;]) this.keyFrames[t+&#x27;&#x27;] = [];

			&#x2F;&#x2F;the push keyframe in array
			this.keyFrames[t+&#x27;&#x27;].push({ &#x27;id&#x27;:id, &#x27;action&#x27;: action });

			return;

		};


		this._sortKeyFrames = function(){

			&#x2F;&#x2F;sort keyframes
			var sorted_keyframes = {};
			var kfs = _.keys(this.keyFrames);
			kfs = _.sortBy(kfs, function(num){ return parseFloat(num); });
			for (var i=0; i&lt; kfs.length;i++){
				sorted_keyframes[kfs[i]] = this.keyFrames[kfs[i]];
			}
			this.keyFrames = sorted_keyframes;

			return;

		};




		&#x2F;**
	     * Method: Update timeline
	     * @param {Number} (optional) update timeline at given time
	     * @return {Boolean} success or not
	     *&#x2F;
		this.update = function(time){
			
			&#x2F;&#x2F;check for &quot;is_ready&quot; flag
			if (!this.is_ready) return;

			&#x2F;&#x2F;check for &quot;is_playing&quot; flag
			&#x2F;&#x2F;if (!this.is_playing) return;
			
			&#x2F;&#x2F;process parameter
			var t = (typeof time != &#x27;undefined&#x27;)? parseInt(time) : false;

			&#x2F;&#x2F;update time
			if (this.timer)	this.time = this.timer.time; &#x2F;&#x2F;update from timer
			else if(t!== false) this.time = t; &#x2F;&#x2F; update from parameter
			else return;

			&#x2F;&#x2F;prevent LEFT timeline offset
			if (this.time&lt;0) this.time = 0;

			&#x2F;&#x2F;prevent RIGHT timeline offset
			var max = this.getDuration()*1000;
			if (this.time&gt;=max){
				this.time = max;
				this.pause();	
			}


			&#x2F;&#x2F;check for keyframes
			t = Math.floor(this.time&#x2F;1000);
			if (this.time2 != t){
			
				var diff = t - this.time2;
				if (diff &gt; 0 &amp;&amp; Math.abs(diff) &lt;= 1){
			
					&#x2F;&#x2F;is linear progress

					&#x2F;&#x2F;get keyframes for this frame
					var kfs = this.keyFrames[t+&#x27;&#x27;];

					&#x2F;&#x2F;exist keyframes?
					if (kfs){
					
						&#x2F;&#x2F;debug.log(&#x27;keyframe found at &#x27;+t);

						for (var i=0; i&lt;kfs.length; i++ ){

							var kf = kfs[i];
							var node = this.node.getDocument().getNodeById(kf.id);
							var action = kf.action;

							if(action&gt;0)	this._enterNode(node);
							else{
								var last_frame = Math.floor(max&#x2F;1000);
								if (t!=last_frame) this._exitNode(node);	
							}
							

						}

						
					}

				}
				else{

					&#x2F;&#x2F;is not linear progress

					&#x2F;&#x2F;get keyframes names: [&#x27;0&#x27;,&#x27;5&#x27;,&#x27;12&#x27;,...]
					var kfs = _.keys(this.keyFrames);
					
					&#x2F;&#x2F;aux array for active nodes
					var active_nodes = [];

					&#x2F;&#x2F;loop trough keyframes before time t
					for (var k =0; k &lt; kfs.length &amp;&amp; parseInt(kfs[k])&lt;=parseInt(t); k++){

						var kf = this.keyFrames[kfs[k]];

						for (var i=0; i&lt;kf.length; i++ ){

							var item = kf[i];
							var node = this.node.getDocument().getNodeById(item.id);
							var action = item.action;

							var index = active_nodes.indexOf(node);

							if(action&gt;0) active_nodes.push(node);
							else active_nodes.splice(index, 1);	
							

						}

					}


					&#x2F;&#x2F;perform resulting &#x27;exit&#x27; nodes
					var need_exit = [];
					for (var i=0; i&lt; this.activeNodes.length; i++){
						var node = this.activeNodes[i];
						if(active_nodes.indexOf(node)&lt;0){
							need_exit.push(node);
						}
						
					}
					for (var i=0; i&lt; need_exit.length; i++) this._exitNode(need_exit[i]);

					&#x2F;&#x2F;perform resulting &#x27;enter&#x27; nodes
					for (var i=0; i&lt; active_nodes.length; i++) this._enterNode(active_nodes[i]);


				}



				&#x2F;&#x2F;this._debug(&#x27;-------------------------------&#x27;);
				&#x2F;&#x2F;for (var i=0; i&lt; this.activeNodes.length; i++) debug.log(&#x27;&#x27;+this.activeNodes[i].nodeName +&#x27;#&#x27;+this.activeNodes[i].id);

				&#x2F;&#x2F;update time2
				this.time2 = t;
				
			}


			&#x2F;&#x2F;console.log(this.activeNodes);

			&#x2F;&#x2F;create timeline event object
			var e = this.buildEventObject(this.node);

			&#x2F;&#x2F;notify &#x27;update&#x27;
			this.trigger(&#x27;update&#x27;, e);

			return ;
			
		};


		this.isActive = function(node_or_id){

			var node = node_or_id;

			if (typeof node_or_id == &#x27;string&#x27;) node = this.node.getDocument().getNodeById(node_or_id);

			if(!node) return;

			if(this.activeNodes.indexOf(node)&gt;=0) return true;

		};

		this._enterNode = function(node){

			&#x2F;&#x2F;check node
			if(!node) return;

			&#x2F;&#x2F;check if already active
			if (this.activeNodes.indexOf(node)&gt;=0) return;

			&#x2F;&#x2F;add to active nodes
			this.activeNodes.push(node);

			&#x2F;&#x2F;create timeline event object
			var e = this.buildEventObject(node);

			&#x2F;&#x2F;notify action
			this.trigger(&#x27;enter&#x27;,e);

			&#x2F;&#x2F;debug action
			this._debug(&#x27;TIMELINE !enter: &#x27;+ node.nodeName +&#x27;#&#x27;+node.id);

			return;

		};

		this._exitNode = function(node){

			&#x2F;&#x2F;check node
			if(!node) return;

			&#x2F;&#x2F;check if active
			var index = this.activeNodes.indexOf(node);
			if (index &lt; 0) return;

			&#x2F;&#x2F;remove from active nodes
			this.activeNodes.splice(index, 1);

			&#x2F;&#x2F;create timeline event object
			var e = this.buildEventObject(node);

			&#x2F;&#x2F;notify action
			this.trigger(&#x27;exit&#x27;,e);

			&#x2F;&#x2F;debug action
			this._debug(&#x27;TIMELINE !exit: &#x27;+ node.nodeName +&#x27;#&#x27;+node.id);

			return;

		};


		&#x2F;**
	     * Play timeline
	     * @return {Boolean} success or not
	     *&#x2F;
		this.play = function(){

			&#x2F;&#x2F;if is scrolling stop scroll
			if(this.is_scrolling) this.stopScroll();

			&#x2F;&#x2F;check for &quot;is_ready&quot; flag
			if (!this.is_ready) return;
			
			&#x2F;&#x2F;play in offset time become replay 
			var max = this.getDuration()*1000;
			if (this.time&gt;=max) return this.replay();

			&#x2F;&#x2F;update &quot;is_playing&quot; flag
			this.is_playing = true;
			
			&#x2F;&#x2F;start timer
			if (this.timer) this.timer.start();

			&#x2F;&#x2F;create timeline event object
			var e = this.buildEventObject(this.node);

			&#x2F;&#x2F;notify &#x27;play&#x27;
			this.trigger(&#x27;play&#x27;, e);


			return;
		};



		this.replay = function(){

			&#x2F;&#x2F;if is scrolling stop scroll
			if(this.is_scrolling) this.stopScroll();

			&#x2F;&#x2F;check for &quot;is_ready&quot; flag
			if (!this.is_ready) return;
			
			this.seekTo(0);
			this.play();

			return;
		};


		&#x2F;**
	     * Pause timeline
	     * @return {Boolean} success or not
	     *&#x2F;
		this.pause = function(){
			
			&#x2F;&#x2F;if is scrolling stop scroll
			if(this.is_scrolling) this.stopScroll();

			if(this.is_playing){

				&#x2F;&#x2F;update &quot;is_playing&quot; flag
				this.is_playing = false;
				
				&#x2F;&#x2F;stop timer
				if (this.timer) this.timer.stop();
				
				&#x2F;&#x2F;create timeline event object
				var e = this.buildEventObject(this.node);

				&#x2F;&#x2F;notify &#x27;pause&#x27;
				this.trigger(&#x27;pause&#x27;, e);

			}
			
			return;

		};
		
		&#x2F;**
	     * Toggle play&#x2F;pause timeline
	     * @return {Boolean} success or not
	     *&#x2F;
		this.toggle = function(){
		
			if (!this.is_scrolling &amp;&amp; !this.is_playing) this.play();
			else this.pause();

			return;
		
		};
		


		this.reset = function(){
		
			&#x2F;&#x2F;update &#x27;is_playing&#x27; flag
			this.is_playing = false;
			
			&#x2F;&#x2F;reset timer
			if (this.timer) this.timer.reset();

			&#x2F;&#x2F;rewind
			this.seekTo(0);
			
			&#x2F;&#x2F;notify reset
			this.trigger(&#x27;reset&#x27;);

			return;
			
		};
		


		this.seekTo = function(t){

			&#x2F;&#x2F;check for &quot;is_ready&quot; flag
			if (!this.is_ready) return;

			&#x2F;&#x2F;trying seek to start?
			t = (t)? (t&lt;=0)? 0 : t : 0;

			&#x2F;&#x2F;update time
			if (this.timer)		this.timer.setTime(t); &#x2F;&#x2F;from timer
			else				this.update(t);

			&#x2F;&#x2F;notify seek
			this.trigger(&#x27;seek&#x27;,t);

			return;
		
		};
		

		this.scroll = function(factor){

			if (!this.scroller) return;

			if(!_.isNumber(factor) || factor===0){

				&#x2F;&#x2F;set scroll factor
				this.stopScroll();

				return;

			}

			&#x2F;&#x2F;pause timeline while scrolling
			this.pause();

			&#x2F;&#x2F;update &#x27;is_scrolling&#x27; flag
			this.is_scrolling = true;

			&#x2F;&#x2F;set scroll factor
			this.scroller.factor = factor;

			&#x2F;&#x2F;sync scroller with timer
			this.scroller.time = this.timer.time;

			&#x2F;&#x2F;start scroll timer if is not already started
			if(this.scroller.paused) this.scroller.start();


			return;
		
		};

		this.stopScroll = function(){

			if (!this.scroller) return;

			&#x2F;&#x2F;set scroll factor
			this.scroller.factor = 0;

			&#x2F;&#x2F;stop scroll timer
			this.scroller.stop();

			&#x2F;&#x2F;update &#x27;is_scrolling&#x27; flag
			this.is_scrolling = false;

			return;
		
		};

		this.onscroll = function(time){

			if(this.is_playing || !this.is_scrolling){
				this.stopScroll();	return;
			}

			&#x2F;&#x2F;process parameter
			var t = (typeof time != &#x27;undefined&#x27;)? parseInt(time) : false;

			&#x2F;&#x2F;update time
			if (this.scroller)	t = this.scroller.time; &#x2F;&#x2F;update from timer

			&#x2F;&#x2F;prevent LEFT timeline offset
			if (t&lt;0){
				t = 0;
				this.stopScroll();
			}

			&#x2F;&#x2F;prevent RIGHT timeline offset
			var max = this.getDuration()*1000;
			if (t&gt;=max){
				t = max;
				this.stopScroll();
			}

			this.seekTo(t);

			return;
		
		};


		this.buildEventObject = function(target){

			var TimelineEvent = {

				&#x27;target&#x27;: target,
				&#x27;active&#x27;: this.activeNodes,
				&#x27;time&#x27;: this.time,
				&#x27;duration&#x27;:this.getDuration()

			};

			return TimelineEvent;

		};





		this.destroy = function(){

			&#x2F;&#x2F;destroy timer
			this.destroyTimer();


			&#x2F;&#x2F;notify destroy
			this.trigger(&#x27;destroy&#x27;);

			return;

		};


		this._debug = function(msg){
			if (this.debug) debug.log(msg);
		}



		this.initialize();


		return this;


	};


	&#x2F;&#x2F;expose

	window.smx.time.Timeline = SMXTimeline;


})(window.smx);
;&#x2F;**
* SMX PlayHead Controller
*
* @class Playhead
*&#x2F;


&#x2F;*

	!enter
	!exit
	!ready

	!start
	!finish
	!play
	!pause
	!seek

	!timeline:update
	!timeline:play
	!timeline:pause
	

 *
 *
 *&#x2F;

(function(smx){

	var SMXPlayhead = function(doc){

		&#x2F;&#x2F;document argument is required!
		if(!doc) return;

		&#x2F;&#x2F;extend with events
		_.extend(this, Backbone.Events);

		&#x2F;&#x2F;SMX Document to use as document data soucre
		this.document = doc;
		
		&#x2F;&#x2F;selection (Array), contains all nodes in which playhead has entered in
		this.selection = [];


		&#x2F;&#x2F;selected timeline
		this.timeline = null;



		&#x2F;&#x2F;return last item in selection array
		this.getCurrentNode = function(){
			return this.selection[this.selection.length-1];
		};


		&#x2F;* PUBLIC METHODS *&#x2F;

		&#x2F;**
		*	@method play
		*	@param [id] {string} id of target node
		*
		*&#x2F;

		this.play = function(id){

			var cnode = null;
			var options = { &#x27;auto&#x27;:true };

			&#x2F;&#x2F;get target node
			if (!id)	cnode = this.getCurrentNode();
			else		cnode = this.document.getNodeById(id);

	 		if(!cnode) return;

	 		&#x2F;&#x2F;check for node accesibility
			if (!cnode.isAccesible()) return;

			&#x2F;&#x2F;if current node has timeline return node play result
			if( cnode.timeline &amp;&amp; this.timeline ) return this.timeline.play();

			&#x2F;&#x2F;if has childs get firstchild
			&#x2F;&#x2F;else get next node in the global timeline
			var first = cnode.first(); if(first) cnode = first;

			if (!cnode.isAccesible()) return;

			return this.go(cnode,options);

		};

		&#x2F;**
		*	@method pause
		*	@param [auto] {boolean} id of target node
		*
		*&#x2F;
		this.pause= function(auto){

			&#x2F;&#x2F;get current node
			if(!this.timeline) return;

			&#x2F;&#x2F;call pause
			this.timeline.pause();
			
			return;
		};

		&#x2F;**
		*	@method toggle
		*
		*&#x2F;
		this.toggle= function(auto){

			&#x2F;&#x2F;node has timeline?
			if(this.timeline) this.timeline.toggle();

			return;

		};

		&#x2F;**
		*	@method next
		*
		*&#x2F;
		this.next= function(auto){
			
			&#x2F;&#x2F;get current node
			var cnode = this.getCurrentNode(); if(!cnode) return;

			&#x2F;&#x2F;get next node
			var tnode = cnode.next(); if (!tnode) return;
			
			&#x2F;&#x2F;check for accesibility
			if(!tnode.isAccesible()) return;

			&#x2F;&#x2F;go to previous node using known swap type and passing recived params	
			return this.go(tnode,{&#x27;swap_type&#x27;:&#x27;next&#x27;,&#x27;auto&#x27;:auto});
			
		};

		&#x2F;**
		*	@method previous
		*
		*&#x2F;		
		this.previous= function(auto){
			
			&#x2F;&#x2F;get current node
			var cnode = this.getCurrentNode(); if(!cnode) return;

			&#x2F;&#x2F;get previous node
			var tnode = cnode.previous(); if (!tnode) return;

			&#x2F;&#x2F;check for accesibility
			if (!tnode.isAccesible()) return;

			&#x2F;&#x2F;go to previous node using known swap type and passing recived params	
			return this.go(tnode,{&#x27;swap_type&#x27;:&#x27;previous&#x27;,&#x27;auto&#x27;:auto});
			
		};
		
		&#x2F;**
		*	@method inside
		*
		*&#x2F;	
		this.inside= function(auto){
		
			&#x2F;&#x2F;get current node
			var cnode = this.getCurrentNode(); if(!cnode) return;

			&#x2F;&#x2F;inside navigation is only allowed above nodes without timeline
			if (cnode.timeline) return;

			&#x2F;&#x2F;has children nodes?
			if (!cnode.children().length&gt;0) return;

			&#x2F;&#x2F;get first child
			var tnode = cnode.childAt(0);

			&#x2F;&#x2F;check for accesibility
			if (!tnode.isAccesible()) return;

			&#x2F;&#x2F;go to child node using known swap type and passing recived params
			return this.go(tnode,{ &#x27;swap_type&#x27;:&#x27;inside&#x27;, &#x27;auto&#x27;:auto });
			
		};

		&#x2F;**
		*	@method outside
		*
		*&#x2F;	
		this.outside= function(auto){
			
			&#x2F;&#x2F;get current node
			var cnode = this.getCurrentNode(); if(!cnode) return;

			&#x2F;&#x2F;has parent node?
			if(!cnode.hasParent()) return;

			&#x2F;&#x2F;get parent node
			var tnode = cnode.parent();

			&#x2F;&#x2F;go to child node using known swap type and passing recived params
			return this.go(tnode,{
				&#x27;swap_type&#x27;:&#x27;outside&#x27;,
				&#x27;auto&#x27;:auto
			});
			
		};

		&#x2F;**
		*	@method forward
		*
		*&#x2F;			
		this.forward= function(auto){
			
			var cnode = this.getCurrentNode(); if(!cnode) return;
			var tnode = cnode.stepForward(); if (!tnode) return;
			
			if (!tnode.isAccesible()) return;
			return this.go(tnode,{&#x27;auto&#x27;:auto});

		};

		&#x2F;**
		*	@method rewind
		*
		*&#x2F;			
		this.rewind= function(auto){
			
			var cnode = this.getCurrentNode(); if(!cnode) return;
			var tnode = cnode.stepBack(); if (!tnode) return;
			
			if (!tnode.isAccesible()) return;
			return this.go(tnode,{&#x27;auto&#x27;:auto});

		};

		&#x2F;**
		*	@method go
		*
		*&#x2F;	
		this.go = function(_node, opt){

			&#x2F;&#x2F;normalize given node, node can be string id or node
			var t_node = (_.isString(_node))? this.document.getNodeById(_node) : _node;
			
			&#x2F;&#x2F; GET CURRENT NODE
			var c_node = this.getCurrentNode();
				
			&#x2F;&#x2F;NODE NOT FOUND ?
			if (!t_node) throw new Error(&#x27;200&#x27;);

			&#x2F;&#x2F;TARGET NODE == CURRENT NODE ?
			&#x2F;&#x2F;if (c_node) if (c_node.id == t_node.id) throw new Error(&#x27;201&#x27;);
			if (c_node == t_node) return c_node;

			&#x2F;&#x2F;TARGET NODE DISPLAY ALLOWED ?
			if (!t_node.isAccesible()) throw new Error(&#x27;202&#x27;);



			&#x2F;&#x2F;INITIALIZE OPTIONS
			var options = {	&#x27;auto&#x27;: false, &#x27;swap_type&#x27;: null };
			if (opt){ options = { &#x27;auto&#x27;: opt.auto || false, &#x27;swap_type&#x27;: opt.swap_type || null } };

			
			
			&#x2F;*
			&#x2F;&#x2F;CONDITIONAL NAVIGATION FLAGS
			&#x2F;&#x2F;AUTO MODE: SKIP REDIRECT?
			if (options.auto==true){

				var s_node = this._getAutoSkipRedirect(t_node);
				if (s_node){
					return this.go(s_node,options);
				}
			}
			*&#x2F;


			&#x2F;*
			&#x2F;&#x2F;OPTIONS.AUTO ?
			if (options.auto==true){

				var s_node = this._getFirstNotCompletedNode(t_node);
				if (s_node){
					options.auto = false;
					return this.go(s_node,options);
				}
			}
			*&#x2F;



			&#x2F;&#x2F;if &#x27;autoplay&#x27; behavior is enabled call 
			if (t_node.autoplay==true &amp;&amp; t_node.children().length&gt;0){
				return this.go(t_node.cnode.getFirstChild(),options);
			}





			&#x2F;&#x2F;We are going to check for multiple node swaping posibilities.
			&#x2F;&#x2F;Being selective should be faster than using the iterative method.
			
			&#x2F;&#x2F;if swap_type parameter was not defined tries to autodetect direct values
			if (!options.swap_type){
			
				if (!c_node) 						options.swap_type = &#x27;from_root&#x27;;
				else if(c_node.isParentOf(t_node))	options.swap_type = &#x27;child&#x27;;
				else if(t_node.isParentOf(c_node))	options.swap_type = &#x27;parent&#x27;;
				else{

					if(c_node.hasParent()){
						var current_parent_node = c_node.parent();
						var target_parent_node = t_node.parent();
						if (current_parent_node.id == target_parent_node.id){
							options.swap_type = &#x27;sibling&#x27;;
						}
					}
					
				}
			
			}
			
			
			&#x2F;&#x2F;Do all necesary &#x27;enter&#x27; and &#x27;exit&#x27; calls for node navigation
			switch(options.swap_type){
			
				case &#x27;outside&#x27;:
					&#x2F;&#x2F;exit from current
					_exitNode(c_node);
					&#x2F;&#x2F;we are already inside t_node because t_node is first parent of c_node
					&#x2F;&#x2F;but re-enter for trigger &#x27;enter&#x27; event 
					_enterNode(t_node);
				break;
				case &#x27;inside&#x27;:
					&#x2F;&#x2F;enter in child node
					_enterNode(t_node);
				break;
				case &#x27;next&#x27;:
				case &#x27;previous&#x27;:
				case &#x27;sibling&#x27;:
					&#x2F;&#x2F;exit from current
					_exitNode(c_node);
					&#x2F;&#x2F;enter in sibling node
					_enterNode(t_node);
				break;
				case &#x27;from_root&#x27;:
					&#x2F;&#x2F;enter all nodes from root to t_node
					_enterStraight(null,t_node);
				break;
				case &#x27;child&#x27;:
					&#x2F;&#x2F;enter all nodes c_node to t_node
					_enterStraight(c_node,t_node);
				break;
				case &#x27;parent&#x27;:
				
					&#x2F;&#x2F;navigate parents from c_node until reach t_node
					var ref_node = c_node;
					var t_node_found = false;
					while (ref_node.hasParent() &amp;&amp; !t_node_found){
						&#x2F;&#x2F;exit from ref_node
						_exitNode(ref_node);
						&#x2F;&#x2F;update ref_node
						ref_node = ref_node.parent();
						&#x2F;&#x2F;t_node found?
						if (ref_node.id == t_node.id) t_node_found = true;
					}
					
					&#x2F;&#x2F;we are already inside t_node because t_node is parent of c_node
					&#x2F;&#x2F;but re-enter for trigger &#x27;enter&#x27; event 
					_enterNode(t_node);
					
				break;
				default:
					&#x2F;&#x2F;iterative method
					_goIterative(c_node,t_node);
				break;
			}
			


			&#x2F;&#x2F;destroy current timeline
			&#x2F;&#x2F;if(this.timeline) this.destroyTimeline();


			&#x2F;&#x2F;fire generic &#x27;stay&#x27; event in resulting current node
			this.trigger(&#x27;stay&#x27;,t_node);

			&#x2F;&#x2F;fire specific node &#x27;stay&#x27; event
			this.trigger(&#x27;stay:&#x27;+t_node.id,t_node);


			&#x2F;&#x2F;notify node navigation completed
			this.trigger(&#x27;ready&#x27;,this);			

			&#x2F;&#x2F;return resultant current node
			return this.getCurrentNode();
			
			
		};
		



		&#x2F;* PRIVATE METHODS *&#x2F;

		&#x2F;*

		this._log= function(msg){

			debug.log(msg);

		};

		*&#x2F;

		&#x2F;*
		this._getFirstNotCompletedNode= function(node){

			var _getFirstNotCompletedNodeRecursive = function(_node){

				if(!_node) return;

				if (!_node.isTimeline() &amp;&amp; _node.children()&gt;0){
					var childnodes = _node.children();
					for (var i=0; i&lt;childnodes.length; i++){
						var child = childnodes[i];
						switch(child.get(&#x27;step&#x27;)){
							case 0:
								return child;
							break;
							case 1:
								if (!child.isTimeline()){
									return _getFirstNotCompletedNodeRecursive(child);	
								}
								else{
									return child;
								}
								
							break;
							default:

							break;
						}

					}
					
				}

				return _node;			

			};


			return _getFirstNotCompletedNodeRecursive(node);
		};
		*&#x2F;


		&#x2F;*
		this._getAutoSkipRedirect= function(_node){

			if(!_node) return;

			if (_node.autoSkip &amp;&amp; _node.autoSkip==true){
			&#x2F;&#x2F;&#x27;autoSkip&#x27; behavior is enabled

				this._log(&#x27;autoSkip&#x27;);

				if(_node.isTimeline()){

					return _node.getNext();

				}
				else{

					if (_node.hasChilds()){
						return _node.getFirstChild();		
					}
					else if(_node.getNext()){
						return _node.getNext();		
					}

				}

				
			}
			else if (_node.autoSkipIfCompleted &amp;&amp; _node.autoSkipIfCompleted==true){

				if(_node.getNext()){
					if (_node.get(&#x27;tracking&#x27;)&gt;=2){
						this._log(&#x27;autoSkipIfCompleted&#x27;);
						return _node.getNext();
					}
				}
			}

			return;

		};
		*&#x2F;

		var _this = this;

		var _goIterative= function(c_node,t_node){
		
			&#x2F;&#x2F;ok! we are gonna navigate from c_node(current node) top t_node(target node). Lets go!
			
			if (!c_node){
			&#x2F;&#x2F;navigate from root
				
				_enterStraight(null,t_node);
				
			}
			else{
			&#x2F;&#x2F;navigate from current node
			
				&#x2F;&#x2F;looks parents for a common parent between current and target node
				var ref_node = c_node;
				var common_parent = null;
				while (ref_node.hasParent() &amp;&amp; !common_parent){

					&#x2F;&#x2F;exit nodes at same that searches
					_exitNode(ref_node);

					ref_node = ref_node.parent();
					if (ref_node.isParentOf(t_node)) common_parent = ref_node;
				}
				
				&#x2F;&#x2F;was common parent found?
				if (common_parent){
					_enterStraight(common_parent,t_node);
				}
				else{
					_enterStraight(null,t_node);
				}

			}
			
			
		};
		
		var _enterStraight= function(parent_node,child_node){
		
			&#x2F;&#x2F;Performs iterative &#x27;enter&#x27; method on child nodes from parent_node to a known child_node

			&#x2F;&#x2F;check if child_node is not child of parent_node
			if(parent_node) if(!parent_node.isParentOf(child_node)) return;
			
			&#x2F;&#x2F;creates a parent nodes array from child node
			var child_node_parents = [];
			
			&#x2F;&#x2F;looks parents and fills the array until reach known parent_node
			var ref_node = child_node;
			var parent_node_reached = false;
			while (ref_node.hasParent() &amp;&amp; !parent_node_reached){
				ref_node = ref_node.parent();
				if(parent_node) if(ref_node.id == parent_node.id) parent_node_reached = true;

				if(!parent_node_reached) child_node_parents.unshift(ref_node);
			}
			
			&#x2F;&#x2F;call &#x27;enter&#x27; method in each parent node
			for (var p=0; p&lt;child_node_parents.length; p++){
				_enterNode(child_node_parents[p]);
			}
			
			&#x2F;&#x2F;call &#x27;enter&#x27; method in child node
			_enterNode(child_node);
		
		};



		&#x2F;**
		 *  pseudo private methods
		 *	  
		 *	_enterNode(node) - instead of - node.enter()
		 *	_exitNode(node) - instead of - node.exit()
		 *	_startNode(node) - instead of - node.start()
		 *	_finishNode(node) - instead of - node.finish()
		 *	
		 *&#x2F;

		var _enterNode= function(_node){

			&#x2F;&#x2F;prevent re-enter in a node
			var selectedIds = _.pluck(_this.selection,&#x27;id&#x27;);
			if(_.contains(selectedIds,_node.id)) return;

			&#x2F;&#x2F;update selection array
			_this.selection.push(_node);

			&#x2F;&#x2F;fire generic &#x27;enter&#x27; event 
			_this.trigger(&#x27;enter&#x27;, _node);

			&#x2F;&#x2F;fire specific node &#x27;enter&#x27; event 
			_this.trigger(&#x27;enter:&#x27;+_node.id, _node);

			return;
		};


		var _exitNode= function(_node){

			&#x2F;&#x2F;clear timeline
			if(_this.timeline) _this.destroyTimeline();

			&#x2F;&#x2F;update blocks array
			_this.selection.pop();

			&#x2F;&#x2F;fire generic &#x27;exit&#x27; event 
			_this.trigger(&#x27;exit&#x27;, _node);

			&#x2F;&#x2F;fire specific node &#x27;exit&#x27; event 
			_this.trigger(&#x27;exit:&#x27;+_node.id, _node);

			return;

		};



		&#x2F;**
		 *	TIMELINE HANDLING
		 *


		this.createTimeline = function(){
		
			var cnode = this.getCurrentNode();
			if(!cnode) return;

			&#x2F;&#x2F;destroy current timeline if needed
			if (this.timeline) this.destroyTimeline();
			
			&#x2F;&#x2F;create timeline
			this.timeline = new smx.time.Timeline(cnode);
			
			&#x2F;&#x2F;setup listeners
			this._bindTimelineListeners();

			return;
		};



		this.destroyTimeline = function(){
			
			&#x2F;&#x2F;remove listeners
			this._unbindTimelineListeners();

			&#x2F;&#x2F;destroy timeline
			this.timeline.destroy();

			&#x2F;&#x2F;reset timeline
			this.timeline = null;
			
			return;
		};


		this._bindTimelineListeners= function(){
		
			if (!this.timeline) return;

			this.timeline.on(&#x27;play&#x27;, this.onTimelinePlay, this);
			this.timeline.on(&#x27;pause&#x27;, this.onTimelinePause, this);
			this.timeline.on(&#x27;update&#x27;, this.onTimelineUpdate, this);
			this.timeline.on(&#x27;seek&#x27;, this.onTimelineSeek, this);
			this.timeline.on(&#x27;reset&#x27;, this.onTimelineReset, this);
			this.timeline.on(&#x27;enter&#x27;, this.onTimelineEnter, this);
			this.timeline.on(&#x27;exit&#x27;, this.onTimelineExit, this);

			return;
		};
		
		this._unbindTimelineListeners= function(){
		
			if (!this.timeline) return;

			this.timeline.off(&#x27;play&#x27;, this.onTimelinePlay, this);
			this.timeline.off(&#x27;pause&#x27;, this.onTimelinePause, this);
			this.timeline.off(&#x27;update&#x27;, this.onTimelineUpdate, this);
			this.timeline.off(&#x27;seek&#x27;, this.onTimelineSeek, this);
			this.timeline.off(&#x27;reset&#x27;, this.onTimelineReset, this);
			this.timeline.off(&#x27;enter&#x27;, this.onTimelineEnter, this);
			this.timeline.off(&#x27;exit&#x27;, this.onTimelineExit, this);
		
			return;
		};

		

		this.onTimelinePlay= function(event){

			this.trigger(&#x27;timeline:play&#x27;, event);

			return;
		};

		this.onTimelinePause= function(event){
		
			this.trigger(&#x27;timeline:pause&#x27;, event);
			return;
		};

		this.onTimelineUpdate= function(event){
		
			this.trigger(&#x27;timeline:update&#x27;, event);
			return;
		};

		this.onTimelineSeek= function(event){
		
			this.trigger(&#x27;timeline:seek&#x27;, event);

			return;
		};

		this.onTimelineReset= function(event){
		
			this.trigger(&#x27;timeline:reset&#x27;, event);

			return;
		};

		this.onTimelineEnter= function(event){
		
			this.trigger(&#x27;timeline:enter&#x27;, event);

			return;
		};

		this.onTimelineExit= function(event){
		
			this.trigger(&#x27;timeline:exit&#x27;, event);

			return;
		};

		*&#x2F;


		return this;

	};



	&#x2F;&#x2F;expose
	smx.Playhead = SMXPlayhead;


})(window.smx);
;(function(smx){

	&#x2F;&#x2F;expose
	smx.tracking = {};



})(window.smx);
;(function(smx){


	smx.tracking.attributes = {};


})(window.smx);;
&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; PROGRESS
&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

(function(smx){


var ProgressAttributeController = {

	name: &#x27;progress&#x27;,

	defaults: &#x27;0&#x27;,

	get: function(model, collection, format){

		&#x2F;&#x2F;model has attribute?
		if(!model.has(this.name)) return;

		&#x2F;&#x2F;get value
		var val = model.get(this.name);

		switch(format){
			case &#x27;raw&#x27;:
				val = collection.raw(model.id,this.name);
			break;
			case &#x27;text&#x27;:
				val = parseFloat(val);
				if (!_.isNumber(val) || _.isNaN(val)) val = parseFloat(this.defaults);
				val = val+&#x27;%&#x27;;
			break;
			case &#x27;value&#x27;:
			default:
				val = parseFloat(val);
				if (!_.isNumber(val) || _.isNaN(val)) val = parseFloat(this.defaults);
			break;
		}

		return val;

	},

	set: function(value, model, collection, important){

		&#x2F;&#x2F;cannot set in non defined values
		if (!this.isDefined(model, collection)) return;

		&#x2F;&#x2F;set is only accepted on non computed values or using important
		if (this.isComputed(model, collection) &amp;&amp; !important) return;

		&#x2F;&#x2F;numeric value is required
		if(!_.isNumber(parseInt(value))) return;

		&#x2F;&#x2F;normailze recived value
		var val = parseInt(value);
		val = (val&gt;100)? val=100 : (val&lt;0)? 0 : val;

		&#x2F;&#x2F;apply value silently
		model.set({&#x27;progress&#x27;:val},{&#x27;silent&#x27;:true});

		&#x2F;*
		&#x2F;&#x2F;ATTRIBUTE PROPAGATION

		&#x2F;&#x2F;propagate -&gt; @status
		&#x2F;&#x2F;@progress directly modifies @status

		&#x2F;&#x2F;every @status change will become STATUS.INCOMPLETE as min
		&#x2F;&#x2F;so use STATUS.INCOMPLETE as default resultant value
		var resultant_status = STATUS.INCOMPLETE;

		&#x2F;&#x2F;@progress &gt;= 100 -&gt; &quot;complete&quot; track
		if(val &gt;= 100) resultant_status = STATUS.COMPLETED;

		&#x2F;&#x2F;set resultant @status silently
		model.set({&#x27;status&#x27;:resultant_status},{&#x27;silent&#x27;:true});
		*&#x2F;

		&#x2F;&#x2F;realease changes trigger &#x27;change&#x27; event 
		model.change();

		&#x2F;&#x2F;return resulting value
		return;

	},


	&#x27;update&#x27;: function(model, collection){

		&#x2F;&#x2F;update only computed values
		if (!this.isComputed(model, collection)) return;

		&#x2F;&#x2F;get raw value
		var raw = collection.raw(model.id, this.name);

		&#x2F;&#x2F;get current value
		var value = collection.get(model.id, this.name);

		var result;

		&#x2F;&#x2F;it&#x27;s computed value...
		&#x2F;&#x2F;so raw value may match any of below
		switch(raw){
			case &#x27;sum&#x27;:
			case &#x27;avg&#x27;:
			case &#x27;auto&#x27;:
			default:

				&#x2F;&#x2F;get node for given model
				var node = collection.document.getNodeById(model.id);

				&#x2F;&#x2F;get node children
				var childs = node.children();

				&#x2F;&#x2F;has childs?
				if (_.isEmpty(childs)){
					result = 0;
				}
				else{

					var count = 0, sum = 0, _name = this.name;

					&#x2F;&#x2F;local reference for nested closures
					var _this = this;

					_.each(childs,function(item,index,list){

						if (collection.has(item.id, _name)){

							&#x2F;&#x2F;get child model
							var child_model = collection.collection.get(item.id);

							if (child_model &amp;&amp; _this.isDefined(child_model, collection)){

								var val = collection.get(child_model.id, _name);

								sum += val;

								count++;

							}


						}
						else{

						}

					});

					if (count&gt;0) result = sum&#x2F;count;
					else result = 0;

				}

			break;
		}


		if (value!==result &amp;&amp; (result||result==0))
			this.set(result, model, collection, true);

		return;


	},

	propagate: function(model, collection, recursive){

		&#x2F;&#x2F;update parent track in collection using document tree hierarchy

		&#x2F;&#x2F;get ref node in collection document
		var node = collection.document.getNodeById(model.id);

		&#x2F;&#x2F;if ref node has no parent exit silently
		if(!node.hasParent()) return;

		&#x2F;&#x2F;get ref node parent
		var parent = node.parent();

		&#x2F;&#x2F;call collection.update for this attribute on parent model
		collection.update(parent.id, this.name);

		&#x2F;&#x2F;recursive propagation
		if (recursive) collection.propagate(parent.id,this.name);

		return;

	},

	isDefined: function(model, collection){

		var raw = collection.raw(model.id, this.name);

		return ((_.isEmpty(raw) &amp;&amp; raw !== 0) || raw === &#x27;none&#x27;)? false : true;

	},

	isComputed: function(model, collection){

		&#x2F;&#x2F;not defined values are also not computables
		if (!this.isDefined(model, collection)) return false;

		&#x2F;&#x2F;get raw value
		var raw = collection.raw(model.id, this.name);

		if (raw===&#x27;auto&#x27;) return true;

		var value = parseInt(raw);

		var is_auto = true;

		if (_.isNumber(value) &amp;&amp; value !== NaN) is_auto = false;

		return is_auto;

	}


};


&#x2F;&#x2F;expose
smx.tracking.attributes.progress = ProgressAttributeController;

})(window.smx);;
&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; PROGRESS
&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

(function(smx){


var parseScore = function (str) {

	&#x2F;&#x2F;invalid input return null
	if(!_.isString(str)) return;

	&#x2F;&#x2F;auto return an empty object
	if(str===&#x27;auto&#x27; || str===&#x27;none&#x27;) return str;

	&#x2F;&#x2F;create default score object
	var obj = { &#x27;value&#x27;: 0, &#x27;min&#x27;: 0, &#x27;max&#x27;: 0	};

	&#x2F;&#x2F;split input by &#x27;&#x2F;&#x27;
	var parts = str.split(&#x27;&#x2F;&#x27;);
	if(parts.length==3){

		&#x2F;&#x2F; 3 parts defines &#x27;value&#x2F;min&#x2F;max&#x27;
		var value = parseFloat(parts[0]) || 0;
		var min = parseFloat(parts[1]) || 0;
		var max = parseFloat(parts[2]) || 0;

		obj = { &#x27;value&#x27;: value, &#x27;min&#x27;: min, &#x27;max&#x27;: max	};


	}
	else if(parts.length==2){

		&#x2F;&#x2F; 2 parts defines &#x27;0&#x2F;min&#x2F;max&#x27;
		var min = parseFloat(parts[0]) || 0;
		var max = parseFloat(parts[1]) || 0;
		
		obj = { &#x27;value&#x27;: 0, &#x27;min&#x27;: min, &#x27;max&#x27;: max	};

	}
	else if(parts.length==1){

		&#x2F;&#x2F; no parts defines &#x27;0&#x2F;max&#x2F;max&#x27;
		var max = parseFloat(parts[0]) || 0;

		obj = { &#x27;value&#x27;: 0, &#x27;min&#x27;: max, &#x27;max&#x27;: max	};
	}

	return obj;  

};



var ScoreAttributeController = {

	name: &#x27;score&#x27;,

	get: function(model, collection, format){

		&#x2F;&#x2F;model has attribute?
		if(!model.has(this.name)) return;

		&#x2F;&#x2F;get value
		var val = model.get(this.name);

		&#x2F;&#x2F;get decomposed value
		var score = parseScore(val);

		if (!score) return;
		else if(score===&#x27;none&#x27;) return;
		else{

			switch(format){
				case &#x27;min&#x27;:
					return score.min;
				break;

				case &#x27;max&#x27;:
					return score.max;
				break;

				case &#x27;string&#x27;:
					return score.value+&#x27;&#x2F;&#x27;+score.min+&#x27;&#x2F;&#x27;+score.max;					
				break;

				case &#x27;value&#x27;:
				default:
					return score.value;					
				break;

			}

		}

		&#x2F;&#x2F;never should reach this line
		return;

	},

	set: function(value, model, collection, important){

		&#x2F;&#x2F;cannot set in non defined values
		if (!this.isDefined(model, collection)) return;

		&#x2F;&#x2F;set is only accepted on non computed values or using important
		if (this.isComputed(model, collection) &amp;&amp; !important) return;

		&#x2F;&#x2F;ok its manual value..
		var score = parseScore(model.get(this.name));

		var is_sum = false;

		if(_.isString(value)){
			if(value.indexOf(&#x27;+&#x27;)===0){
				is_sum = true;
			}
			else if(value.indexOf(&#x27;-&#x27;)===0){
				is_sum = true;
			}
		}

		value = parseFloat(value);

		if(!_.isNumber(value)) return;

		var cval = score.value;

		var result = value;
		if(is_sum) result = cval + value;

		var is_change = (result!=cval)? true : false;

		if(is_change){

			&#x2F;&#x2F;apply changes silentlly
			var score_string = result + &#x27;&#x2F;&#x27; + score.min + &#x27;&#x2F;&#x27; + score.max;
			model.set({&#x27;score&#x27;:score_string}, {&#x27;silent&#x27;:true});

		}

		&#x2F;*
		&#x2F;&#x2F;ATTRIBUTE PROPAGATION

		&#x2F;&#x2F;propagate -&gt; @status
		&#x2F;&#x2F;@progress directly modifies @status

		&#x2F;&#x2F;every @status change will become STATUS.INCOMPLETE as min
		&#x2F;&#x2F;so use STATUS.INCOMPLETE as default resultant value
		var resultant_status = STATUS.INCOMPLETE;

		&#x2F;&#x2F;@progress &gt;= 100 -&gt; &quot;complete&quot; track
		if(val &gt;= 100) resultant_status = STATUS.COMPLETED;

		&#x2F;&#x2F;set resultant @status silently
		model.set({&#x27;status&#x27;:resultant_status},{&#x27;silent&#x27;:true});
		*&#x2F;

		&#x2F;&#x2F;realease changes trigger &#x27;change&#x27; event 
		model.change();

		&#x2F;&#x2F;return resulting value
		return;

	},


	&#x27;update&#x27;: function(model, collection){

		&#x2F;&#x2F;update only defined computed values
		if ( !this.isComputed(model, collection) ) return;

		&#x2F;&#x2F;get raw value
		var raw = collection.raw(model.id, this.name);

		&#x2F;&#x2F;get current value
		var value = collection.get(model.id, this.name);

		&#x2F;&#x2F;it&#x27;s computed value...
		&#x2F;&#x2F;so raw value may match any of below
		switch(raw){
			case &#x27;sum&#x27;:
			case &#x27;auto&#x27;:
			default:

				&#x2F;&#x2F;get node for given model
				var node = collection.document.getNodeById(model.id);

				&#x2F;&#x2F;get node children
				var childs = node.children();

				var result;

				&#x2F;&#x2F;has childs?
				if (_.isEmpty(childs)){
					result = 0;
				}
				else{

					var count = 0, sum = 0, _name = this.name;

					&#x2F;&#x2F;local reference for nested closures
					var _this = this;

					_.each(childs,function(item,index,list){

						if (collection.has(item.id, _name)){

							&#x2F;&#x2F;get child model
							var child_model = collection.collection.get(item.id);

							if (child_model &amp;&amp; _this.isDefined(child_model, collection)){

								var val = collection.get(child_model.id, _name);

								sum += val;

								count++;

							}


						}
						else{

						}

					});

					result = sum || 0;
				}


			break;
		}


		if (value!==result &amp;&amp; (result||result==0))
			this.set(result, model, collection, true);

		return;


	},

	propagate: function(model, collection, recursive){

		&#x2F;&#x2F;update parent track in collection using document tree hierarchy

		&#x2F;&#x2F;get ref node in collection document
		var node = collection.document.getNodeById(model.id);

		&#x2F;&#x2F;if ref node has no parent exit silently
		if(!node.hasParent()) return;

		&#x2F;&#x2F;get ref node parent
		var parent = node.parent();

		&#x2F;&#x2F;call collection.update for this attribute on parent model
		collection.update(parent.id, this.name);

		&#x2F;&#x2F;recursive propagation
		if (recursive) collection.propagate(parent.id,this.name);

		return;

	},

	isDefined: function(model, collection){

		var raw = collection.raw(model.id, this.name);

		return ( _.isEmpty(raw) &amp;&amp; raw!==&#x27;none&#x27; )? false : true;

	},

	isComputed: function(model, collection){

		&#x2F;&#x2F;not defined values are also not computables
		if (!this.isDefined(model, collection)) return false;

		&#x2F;&#x2F;get raw value
		var raw = collection.raw(model.id, this.name);

		if(raw===&#x27;auto&#x27;||raw===&#x27;sum&#x27;)	return true;
		else							return false;

	}


};


&#x2F;&#x2F;expose
smx.tracking.attributes.score = ScoreAttributeController;

})(window.smx);;
(function(smx) {


	var Track = Backbone.Model.extend({

		 defaults: {},

		initialize: function(){
		
			return this;

		}
		
	});

	&#x2F;&#x2F;return Track;
	&#x2F;&#x2F;expose

	smx.tracking.Track = Track;


})(window.smx);
;&#x2F;**

Track Attributes
@module Track Attributes

*&#x2F;


(function(smx){

 	var SMXTrackingController = {};


 	var parseScoreString = function (track) {

		var str = track.get(&#x27;score&#x27;);

		&#x2F;&#x2F;invalid input return null
		if(!_.isString(str)) return;

		&#x2F;&#x2F;auto return an empty object
		if(str===&#x27;auto&#x27; || str===&#x27;none&#x27;) return str;

		&#x2F;&#x2F;create default score object
		var obj = { &#x27;value&#x27;: 0, &#x27;min&#x27;: 0, &#x27;max&#x27;: 0	};

		&#x2F;&#x2F;split input by &#x27;&#x2F;&#x27;
		var parts = str.split(&#x27;&#x2F;&#x27;);
		if(parts.length==3){

			&#x2F;&#x2F; 3 parts defines &#x27;value&#x2F;min&#x2F;max&#x27;
			var value = parseFloat(parts[0]) || 0;
			var min = parseFloat(parts[1]) || 0;
			var max = parseFloat(parts[2]) || 0;

			obj = { &#x27;value&#x27;: value, &#x27;min&#x27;: min, &#x27;max&#x27;: max	};


		}
		else if(parts.length==2){

			&#x2F;&#x2F; 2 parts defines &#x27;0&#x2F;min&#x2F;max&#x27;
			var min = parseFloat(parts[0]) || 0;
			var max = parseFloat(parts[1]) || 0;
			
			obj = { &#x27;value&#x27;: 0, &#x27;min&#x27;: min, &#x27;max&#x27;: max	};

		}
		else if(parts.length==1){

			&#x2F;&#x2F; no parts defines &#x27;0&#x2F;max&#x2F;max&#x27;
			var max = parseFloat(parts[0]) || 0;

			obj = { &#x27;value&#x27;: 0, &#x27;min&#x27;: max, &#x27;max&#x27;: max	};
		}

		return obj;  

 	};



 	&#x2F;**
 	 *	Track Expresions
 	 *
 	 *	track trigger definition format
 	 *
 	 *	!parent:score:+100
 	 *  #nodeId:access:0
 	 *  #nodeId:access:0,!parent:score:+100
 	 *
 	 *&#x2F;



 	var runTrackExpression = function (track, exp, manager ) {

 		var result = [];

		if(!_.isString(exp)) return;

   		var exps = [];

		if(exp.indexOf(&#x27;,&#x27;))  exps = exp.split(&#x27;,&#x27;);
 		else 					exps.push(exp);

 		for(var i=0; i&lt; exps.length;i++){

			var cmd_parts = exps[i].split(&#x27;:&#x27;);

			&#x2F;&#x2F;cmd requires 3 parts
			if(cmd_parts.length==3){

				var trackId = cmd_parts[0];
				var property = cmd_parts[1];
				var value = cmd_parts[2];

				&#x2F;&#x2F;get track
				if(trackId.indexOf(&#x27;!&#x27;) === 0){

					var ins = trackId.substr(1);

					var node = manager.document.getNodeById(track.id);

					if(!node) ins = &#x27;null&#x27;;

					switch(ins){

						case &#x27;null&#x27;:
							node = null;
						break;

						case &#x27;next&#x27;:
							node = node.next();
						break;
						case &#x27;previous&#x27;:
							node = node.previous();
						break;
						case &#x27;parent&#x27;:
							node = node.parent();
						break;
						case &#x27;childs&#x27;:
							node = node.children();
						break;
						case &#x27;firstchild&#x27;:
							node = node.first();
						break;
						case &#x27;allnext&#x27;:
							res = [];
							var next = node.next();
							while(next){
								res.push(next);
								next = next.next();
							}
							if (res.length&gt;0) 	node = res;
							else				node = null;
						break;
						case &#x27;allprevious&#x27;:
							res = [];
							var prev = node.previous();
							while(prev){
								res.push(prev);
								prev = prev.previous();
							}
							if (res.length&gt;0) 	node = res;
							else				node = null;
						break;
					}

					if(node){
						if(_.isArray(node))		trackId = _.pluck(node,&#x27;id&#x27;);
						else					trackId = node.id;
					}

				}
				else if(trackId.indexOf(&#x27;#&#x27;) === 0){
					trackId = trackId.substr(1);
				}
				else{
					trackId = trackId;					
				}

				var command = {
					&#x27;id&#x27;: trackId,
					&#x27;property&#x27;: property,
					&#x27;value&#x27;: value
				};

				result.push(command);		

			}
			else if(cmd_parts[0].indexOf(&#x27;@&#x27;) === 0){

				var ins = cmd_parts[0].substr(1);
				var playhead = manager.document.playhead;
				if (_.isFunction(playhead[ins])){
					playhead[ins]();
				}	

			}

 		}



		var commands = result;

		for(var i=0; i&lt; commands.length;i++){
			var cmd = commands[i];
			manager.set(cmd.id, cmd.property, cmd.value);
		}


 		return;

 	};




	var AttributeController = {};



	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
	&#x2F;&#x2F; EXAMPLE
	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

	var ExampleAttributeHandler = {

		&#x27;name&#x27;: &#x27;name&#x27;,

		&#x27;default&#x27;: &#x27;name&#x27;,

		&#x27;set&#x27;:function(value, track, manager, important) {},

		&#x27;get&#x27;:function(track, manager, format){},

		&#x27;onchange&#x27;: function(track, manager){},

		&#x27;onenter&#x27;: function(track, manager, playheadEvent){},

		&#x27;onexit&#x27;: function(track, manager, playheadEvent){},

		&#x27;onupdate&#x27;: function(track, manager, playheadEvent){},

		&#x27;onplay&#x27;: function(track, manager, playheadEvent){},

		&#x27;onpause&#x27;: function(track, manager, playheadEvent){}

	};




	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
	&#x2F;&#x2F; PROGRESS
	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

	AttributeController.progress = {

		&#x27;name&#x27;: &#x27;progress&#x27;,

		&#x27;default&#x27;: 0,

		&#x27;get&#x27;: function(track, manager, format){

			var val = track.get(this.name);


			switch(format){
				case &#x27;raw&#x27;:		
					var node = manager.document.getNodeById(track.id);
					val = node[0].getAttribute(&#x27;track-&#x27;+this.name);
				break;
				case &#x27;text&#x27;:
					val = val+&#x27;%&#x27;;
				break;
				case &#x27;value&#x27;:
				default:
				break;
			}

			return val;

		},

		&#x27;set&#x27;: function(value, track, manager, important){

			&#x2F;&#x2F;numeric value is required
			if(!_.isNumber(parseInt(value))) return;

			&#x2F;&#x2F;normailze recived value
			var val = parseInt(value);
			val = (val&gt;100)? val=100 : (val&lt;0)? 0 : val;

			&#x2F;&#x2F;will change?
			var is_change = false;
			if(important) is_change = true;
			else{

				&#x2F;&#x2F;get current value
				var cval = parseInt(track.get(&#x27;progress&#x27;));

				&#x2F;&#x2F;determine if represents value change
				is_change = (val&gt;cval)? true : false;

			}		

			&#x2F;&#x2F;will?
			if(is_change){

				&#x2F;&#x2F;apply value silently
				if(is_change) track.set({&#x27;progress&#x27;:val},{&#x27;silent&#x27;:true});


				&#x2F;&#x2F;ATTRIBUTE PROPAGATION

				&#x2F;&#x2F;propagate -&gt; @status
				&#x2F;&#x2F;@progress directly modifies @status

				&#x2F;&#x2F;every @status change will become STATUS.INCOMPLETE as min
				&#x2F;&#x2F;so use STATUS.INCOMPLETE as default resultant value
				var resultant_status = STATUS.INCOMPLETE;

				&#x2F;&#x2F;@progress &gt;= 100 -&gt; &quot;complete&quot; track
				if(val &gt;= 100) resultant_status = STATUS.COMPLETED;

				&#x2F;&#x2F;set resultant @status silently
				track.set({&#x27;status&#x27;:resultant_status},{&#x27;silent&#x27;:true});


			}


			&#x2F;&#x2F;realease changes trigger &#x27;change&#x27; event 
			track.change();

			&#x2F;&#x2F;return resulting value
			return val;

		},

		&#x27;refresh&#x27;: function(track, manager){

			&#x2F;&#x2F;refresh only automatic values
			var auto = this.isAuto(track, manager);
			if (!auto) return;

			&#x2F;&#x2F;ok is automatic value, so lets calculate it
			&#x2F;&#x2F;get raw value
			var raw = manager.raw(track.id, this.name);

			var value;

			switch(raw){
				
				case &#x27;sum&#x27;:
				case &#x27;avg&#x27;:
				case &#x27;auto&#x27;:
				default:

					&#x2F;&#x2F;get node for given track
					var node = manager.document.getNodeById(track.id);

					var childs = node.children();

					if (childs &amp;&amp; childs.length&gt;0){

						var count = 0, sum = 0, n = childs.length;
						for (var i=0; i&lt; n;i++){

							var child = childs[i];

							if (manager.has(child.id, this.name)){

								var c_value = manager.get(child.id, this.name);

								sum += c_value;

								count++;

							}
							else{

							}

						}

						var result = sum&#x2F;count;

						manager.set(track.id,&#x27;progress&#x27;,result);

					}
					else{



					}



				break;
			}

		},

		&#x27;isAuto&#x27;: function(track, manager){

			var raw = manager.raw(track.id, this.name);

			var value = parseInt(raw);

			var is_auto = true;

			if (_.isNumber(value) &amp;&amp; value !== NaN) is_auto = false;

			return is_auto;

		},


		&#x27;onchange&#x27;: function(track, manager){

			&#x2F;&#x2F;get reffering node
			var node = manager.document.getNodeById(track.id);

			var parent = node.parent();

			if(parent) manager.refresh(parent.id, &#x27;progress&#x27;);

			return;

		},

		&#x27;onupdate&#x27;: function(track, manager, playheadEvent){

			if(!track) return;

			var p = parseFloat((playheadEvent.time*100)&#x2F;(playheadEvent.duration*1000));

			manager.set(track.id, this.name, p);

			return;

		}

	};


	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
	&#x2F;&#x2F; STATUS PROPERTY
	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

	var STATUS = {};
	STATUS.NOTATTEMPTED    	= 0;    	
	STATUS.INCOMPLETE      	= 1;    	&#x2F;&#x2F; views&gt;0
	STATUS.COMPLETED      	= 2;    	&#x2F;&#x2F; played &amp; completed
	STATUS.FAILED          	= 3;    	&#x2F;&#x2F; completed &amp; score&lt;minScore
	STATUS.PASSED          	= 4;    	&#x2F;&#x2F; completed &amp; score&gt;=minSCore
	STATUS.BONUS          	= 5;    	&#x2F;&#x2F; bonus :D

	AttributeController.status = {

		&#x27;name&#x27;:&#x27;status&#x27;,

		&#x27;defaults&#x27;:STATUS.NOTATTEMPTED,

		&#x27;get&#x27;:function(track, manager, format){

			var node = manager.document.getNodeById(track.id);
			value_raw = node[0].getAttribute(&#x27;track-&#x27;+this.name);

			var value = parseInt(track.get(&#x27;status&#x27;));

			if (_.isUndefined(value_raw) || _.isNull(value_raw) || _.isNaN(value_raw) || value_raw == &#x27;none&#x27;)
				if(format!=&#x27;raw&#x27;) value = this.defaults;


			switch(format){
				case &#x27;raw&#x27;:		
					value = value_raw;
				break;
				case &#x27;text&#x27;:
					var keys = _.keys(STATUS);
					var values = _.values(STATUS);

					var index = values.indexOf(value);
					if(index&gt;=0){
						var name = (keys[index]).toLowerCase();
						value = name;						
					}
				break;
				case &#x27;code&#x27;:
					var keys = _.keys(STATUS);
					var values = _.values(STATUS);

					var index = values.indexOf(value);
					if(index&gt;=0){
						var name = (keys[index]).toLowerCase();
						value = name[0].toUpperCase();						
					}
				break;
				case &#x27;value&#x27;:
				default:
				break;
			}

			return value;

		},


		&#x27;set&#x27;:function(value, track, manager, important) {
			
			&#x2F;&#x2F;filter input value
			&#x2F;&#x2F;various input value formats are accepted

			var val = value;

			&#x2F;&#x2F;numeric value?
			if(_.isNumber(parseInt(val)) &amp;&amp; !_.isNaN(parseInt(val))){

				&#x2F;&#x2F;ensure is integer
				val = parseInt(value);

				&#x2F;&#x2F;ensure val is between valid range
				val = Math.max(val,0);
				val = Math.min(val,_.size(STATUS)-1);

			}
			else if(_.isString(val) &amp;&amp; val!=&#x27;&#x27;){

				&#x2F;&#x2F;set input to uppercase
				val = val.toUpperCase();

				&#x2F;&#x2F;check if val exists as charcode
				var codes = _.keys(STATUS);
				for (var i=0; i&lt; codes.length;i++){
					if (codes[i].indexOf(val) == 0){
						val = STATUS[codes[i]];
						break;
					}
				}

				&#x2F;&#x2F;if was found val should be a number
				&#x2F;&#x2F;else exit due to invalid input
				if(!_.isNumber(val)) return;

			}
			else{

				&#x2F;&#x2F;invalid input
				&#x2F;&#x2F;not number neither string
				return;
			}



			&#x2F;&#x2F;get current value
			var cval = parseInt(track.get(&#x27;status&#x27;));
			cval = (!_.isFinite(cval))? this.defaults : cval;

			&#x2F;&#x2F;will only be considered as a change when increasing 
			var is_change = (val&gt;cval)? true : false;

			&#x2F;&#x2F;if(important) is_change = true;
			&#x2F;&#x2F;else{


			if(is_change){
				
				switch(val){

					case STATUS.NOTATTEMPTED:


					break;

					case STATUS.INCOMPLETE:

						&#x2F;&#x2F;autocomplete?
						var autocomplete = track.get(&#x27;autocomplete&#x27;);
						if(autocomplete &amp;&amp; autocomplete==&#x27;true&#x27;) val = STATUS.COMPLETED;
						else{

							&#x2F;&#x2F;tracks refering node with duration == 0
							&#x2F;&#x2F;automatically become &#x27;completed&#x27;

							&#x2F;&#x2F;get reffering node
							&#x2F;&#x2F;var node = manager.document.getNodeById(track.id);

							&#x2F;&#x2F;get duration
							&#x2F;&#x2F;var duration = node.getDuration();

							&#x2F;&#x2F;if(duration == 0) val = STATUS.COMPLETED;

						}

						if (val == STATUS.COMPLETED){

							&#x2F;&#x2F;check for &#x27;autopass&#x27;
							var autopass = track.get(&#x27;autopass&#x27;);
							var score = parseScoreString(track);

							if(autopass &amp;&amp; autopass==&#x27;true&#x27;) val = STATUS.PASSED;
							else if (!score || score==&#x27;none&#x27; || score==&#x27;auto&#x27;) val = STATUS.PASSED;
							else{

								&#x2F;&#x2F;tracks with score.min == 0
								&#x2F;&#x2F;automatically become &#x27;passed&#x27;

									if(score.min === 0) 				resultant_status = STATUS.PASSED;
									else if(score.value&gt;=score.min) 	resultant_status = STATUS.PASSED;
									else 								resultant_status = STATUS.FAILED;

							}

						}
						
					break;

					case STATUS.COMPLETED:

						&#x2F;*

							controlled by method? node.track.validate() ? 



							&#x2F;&#x2F;check for &#x27;autopass&#x27;
							var autopass = track.get(&#x27;autopass&#x27;);
							var score = parseScoreString(track);

							if(autopass &amp;&amp; autopass==&#x27;true&#x27;) val = STATUS.PASSED;
							else if (!score || score==&#x27;none&#x27; || score==&#x27;auto&#x27;) val = STATUS.PASSED;
							else{

								&#x2F;&#x2F;tracks with score.min == 0
								&#x2F;&#x2F;automatically become &#x27;passed&#x27;
								
									if(score.min === 0) 				resultant_status = STATUS.PASSED;
									else if(score.value&gt;=score.min) 	resultant_status = STATUS.PASSED;
									else 								resultant_status = STATUS.FAILED;

							}
					
						*&#x2F;

					break;

					case STATUS.FAILED:

					break;

					case STATUS.PASSED:
					
					break;

					case STATUS.BONUS:


					break;															

				}


				&#x2F;&#x2F;ensure progress 100 if completed
				if(val&gt;STATUS.INCOMPLETE) track.set({&#x27;progress&#x27;:100},{&#x27;silent&#x27;:true});


				&#x2F;&#x2F;apply new value silently
				if(is_change) track.set({&#x27;status&#x27;:val},{&#x27;silent&#x27;:true});


				&#x2F;&#x2F;realease &#x27;change&#x27; track event
				track.change();

			}


			&#x2F;&#x2F;return resulting value
			return (is_change)? val : cval;

		},

		onchange: function (track, manager, previous_value) {

			var val = track.get(&#x27;status&#x27;);
			switch(val){

				case STATUS.NOTATTEMPTED:

				break;


				case STATUS.INCOMPLETE:

					var onattempt = track.get(&#x27;onattempt&#x27;);
					if(onattempt) runTrackExpression(track,onattempt, manager);

				break;


				case STATUS.COMPLETED:
				
					if (previous_value&lt;STATUS.INCOMPLETE){
						var onattempt = track.get(&#x27;onattempt&#x27;);
						if(onattempt) runTrackExpression(track,onattempt, manager);
					}

					var oncomplete = track.get(&#x27;oncomplete&#x27;);
					if(oncomplete) runTrackExpression(track,oncomplete, manager);

				break;


				case STATUS.FAILED:

					if (previous_value&lt;STATUS.INCOMPLETE){
						var onattempt = track.get(&#x27;onattempt&#x27;);
						if(onattempt) runTrackExpression(track,onattempt, manager);
					}

					if (previous_value&lt;STATUS.COMPLETED){
						var oncomplete = track.get(&#x27;oncomplete&#x27;);
						if(oncomplete) runTrackExpression(track,oncomplete, manager);
					}

					var onfail = track.get(&#x27;onfail&#x27;);
					if(onfail) runTrackExpression(track,onfail, manager);

				
				break;


				case STATUS.PASSED:

					if (previous_value&lt;STATUS.INCOMPLETE){
						var onattempt = track.get(&#x27;onattempt&#x27;);
						if(onattempt) runTrackExpression(track,onattempt, manager);
					}

					if (previous_value&lt;STATUS.COMPLETED){
						var oncomplete = track.get(&#x27;oncomplete&#x27;);
						if(oncomplete) runTrackExpression(track,oncomplete, manager);
					}

					var onpass = track.get(&#x27;onpass&#x27;);
					if(onpass) runTrackExpression(track,onpass, manager);

				
				break;


				case STATUS.BONUS:

					if (previous_value&lt;STATUS.INCOMPLETE){
						var onattempt = track.get(&#x27;onattempt&#x27;);
						if(onattempt) runTrackExpression(track,onattempt, manager);
					}

					if (previous_value&lt;STATUS.COMPLETED){
						var oncomplete = track.get(&#x27;oncomplete&#x27;);
						if(oncomplete) execTrackCommand(track,oncomplete, manager);
					}

					if (previous_value&lt;STATUS.PASSED){
						var onpass = track.get(&#x27;onpass&#x27;);
						if(onpass) execTrackCommand(track,onpass, manager);
					}

					var onbonus = track.get(&#x27;onbonus&#x27;);
					if(onbonus) execTrackCommand(track,onbonus, manager);
				

				break;															

			}


			
		}


	};


	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
	&#x2F;&#x2F; ACCESS
	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

	var ACCESS = {};
	ACCESS.ENABLED 	    = 0;    		&#x2F;&#x2F; its allow to enter
	ACCESS.DISABLED     = 1;    		&#x2F;&#x2F; enter is disabled
	ACCESS.HIDDEN		= 2;    		&#x2F;&#x2F; enter is not allowed


	AttributeController.access = {

		&#x27;name&#x27;: &#x27;access&#x27;,

		&#x27;defaults&#x27;: ACCESS.ENABLED,

		&#x27;get&#x27;:function(track, manager, format){

			var node = manager.document.getNodeById(track.id);
			value_raw = node[0].getAttribute(&#x27;track-&#x27;+this.name);

			var value = parseInt(track.get(&#x27;access&#x27;));

			if (_.isUndefined(value_raw) || _.isNull(value_raw) || _.isNaN(value_raw) || value_raw == &#x27;none&#x27;)
				if(format!=&#x27;raw&#x27;) value = this.defaults;

			switch(format){
				case &#x27;raw&#x27;:
					value = value_raw;
				break;
				case &#x27;text&#x27;:
					var keys = _.keys(ACCESS);
					var values = _.values(ACCESS);

					var index = values.indexOf(value);
					if(index&gt;=0){
						var name = (keys[index]).toLowerCase();
						value = name;						
					}
					value = name;

				break;

				case &#x27;code&#x27;:
					var keys = _.keys(ACCESS);
					var values = _.values(ACCESS);

					var index = values.indexOf(value);
					if(index&gt;=0){
						var name = (keys[index]).toLowerCase();
						value = name[0].toUpperCase();						
					}
				break;

				case &#x27;value&#x27;:
				default:
				break;
			}

			return value;

		},


		&#x27;set&#x27;:function(value, track, manager, important) {
			
			&#x2F;&#x2F;filter input value
			&#x2F;&#x2F;various input value formats are accepted

			var val = value;

			&#x2F;&#x2F;numeric value
			if(_.isNumber(parseInt(val)) &amp;&amp; !_.isNaN(parseInt(val))){

				&#x2F;&#x2F;ensure is integer
				val = parseInt(value);

				&#x2F;&#x2F;ensure val is between valid range
				val = Math.max(val,0);
				val = Math.min(val,_.size(ACCESS)-1);

			}
			else if(_.isString(val) &amp;&amp; val!=&#x27;&#x27;){

				&#x2F;&#x2F;set input to uppercase
				val = val.toUpperCase();

				&#x2F;&#x2F;check if val exists as charcode
				var codes = _.keys(ACCESS);
				for (var i=0; i&lt; codes.length;i++){
					if (codes[i].indexOf(val) == 0){
						val = ACCESS[codes[i]];
						break;
					}
				}

				&#x2F;&#x2F;if was found val should be a number
				&#x2F;&#x2F;else exit due to invalid input
				if(!_.isNumber(val)) return;

			}
			else{

				&#x2F;&#x2F;invalid input
				&#x2F;&#x2F;not number neither string
				return;
			}


			&#x2F;&#x2F;get current value
			var cval = parseInt(track.get(&#x27;access&#x27;));

			&#x2F;&#x2F;will only be considered as a change when increasing 
			var is_change = (val!=cval)? true : false;

			&#x2F;&#x2F;set value only if is greater than previous value
			if(is_change) track.set(&#x27;access&#x27;,val);

			return val;

		}

	};





	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
	&#x2F;&#x2F; VIEWS
	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

	AttributeController.views = {

		&#x27;name&#x27;:&#x27;views&#x27;,

		&#x27;get&#x27;:function(track, manager, format){
			if (format === &#x27;raw&#x27;){
				var node = manager.document.getNodeById(track.id);
				return node[0].getAttribute(&#x27;track-&#x27;+this.name);
			}
			else{
				return track.get(this.name);
			}

		},

		&#x27;set&#x27;:function(value, track, manager, important){
			
			if(!_.isNumber(parseInt(value))) return;

			var val = parseInt(value);
			var cval = parseInt(track.get(&#x27;views&#x27;));

			&#x2F;&#x2F;set value only if is greater than previous value
			if(val&gt;cval) track.set(&#x27;views&#x27;,val);

			return val;

		},


		&#x27;onchange&#x27;: function(track, manager){

			if(track.get(&#x27;views&#x27;) == 1){
				if(track.get(&#x27;status&#x27;)&lt;STATUS.INCOMPLETE){
					manager.set(track.id, &#x27;status&#x27;, STATUS.INCOMPLETE);
				}					
			}

			return;

		},
		&#x27;onenter&#x27;: function(track, manager, playheadEvent){

			var val = parseInt(track.get(&#x27;views&#x27;));
			if(_.isNaN(val)) val = 0;
			manager.set(track.id, &#x27;views&#x27;, val+1);
			return;

		}
	};


	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
	&#x2F;&#x2F; SCORE
	&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

	AttributeController.score = {

		&#x27;name&#x27;:&#x27;score&#x27;,

		&#x27;get&#x27;:function(track, manager, format){

			if (format === &#x27;raw&#x27;){
				var node = manager.document.getNodeById(track.id);
				return node[0].getAttribute(&#x27;track-&#x27;+this.name);
			}

			var score = parseScoreString(track);

			&#x2F;&#x2F;no score object?
			if (!score) return;
			else if(score===&#x27;none&#x27;) return;
			else{
			&#x2F;&#x2F;proceed with score object

				if(score===&#x27;auto&#x27;) this.interpolate(track,manager);

				score = parseScoreString(track);

				switch(format){
					case &#x27;min&#x27;:
						return score.min;
					break;

					case &#x27;max&#x27;:
						return score.max;
					break;

					case &#x27;string&#x27;:
						return score.value+&#x27;&#x2F;&#x27;+score.min+&#x27;&#x2F;&#x27;+score.max;					
					break;

					case &#x27;value&#x27;:
					default:
						return score.value;					
					break;

				}

			}

			&#x2F;&#x2F;never should reach this line
			return;

		},

		&#x27;interpolate&#x27;: function(track, manager){

			&#x2F;&#x2F;get refering node
			var node = manager.document.getNodeById(track.id);

			&#x2F;&#x2F;check for interpolated values
			var raw = manager.get(track.id, this.name, &#x27;raw&#x27;);

			if(raw===&#x27;auto&#x27;){

				var childs = node.children();
				if(childs.length==0) return;

				var value = 0;
				for (var i = 0; i&lt; childs.length; i++){
					var val = manager.get(childs[i].id,this.name,&#x27;value&#x27;);
					if (!_.isUndefined(val)) value+=parseFloat(val);
				}

				var min = 0;
				for (var i = 0; i&lt; childs.length; i++){
					var val = manager.get(childs[i].id,this.name,&#x27;min&#x27;);
					if (!_.isUndefined(val)) min+=parseFloat(val);
				}

				var max = 0;
				for (var i = 0; i&lt; childs.length; i++){
					var val = manager.get(childs[i].id,this.name,&#x27;max&#x27;);
					if (!_.isUndefined(val)) max+=parseFloat(val);
				}

				&#x2F;&#x2F;apply interpolated value
				var score_string = value + &#x27;&#x2F;&#x27; + min + &#x27;&#x2F;&#x27; + max;
				track.set({&#x27;score&#x27;:score_string},{&#x27;silent&#x27;:true});

			}


		},

		&#x27;isInterpolated&#x27;: function (track, manager) {
		
			&#x2F;&#x2F;check for interpolated values
			var raw = manager.get(track.id, this.name, &#x27;raw&#x27;);

			if(raw===&#x27;auto&#x27;) return true;
			else 			 return false;			

		},

		&#x27;refresh&#x27;: function(track, manager){

			&#x2F;&#x2F;get refering node
			var node = manager.document.getNodeById(track.id);

			&#x2F;&#x2F;check for interpolated values
			var raw = manager.get(track.id, this.name, &#x27;raw&#x27;);
			var score = parseScoreString(track);

			if(raw===&#x27;auto&#x27;){

				var childs = node.children();
				if(childs.length==0) return;

				var value = 0;
				for (var i = 0; i&lt; childs.length; i++){
					var val = manager.get(childs[i].id,&#x27;score&#x27;,&#x27;value&#x27;);
					if (!_.isUndefined(val)) value+=parseFloat(val);
				}

				var min = 0;
				for (var i = 0; i&lt; childs.length; i++){
					var val = manager.get(childs[i].id,&#x27;score&#x27;,&#x27;min&#x27;);
					if (!_.isUndefined(val)) min+=parseFloat(val);
				}

				var max = 0;
				for (var i = 0; i&lt; childs.length; i++){
					var val = manager.get(childs[i].id,&#x27;score&#x27;,&#x27;max&#x27;);
					if (!_.isUndefined(val)) max+=parseFloat(val);
				}

				&#x2F;&#x2F;apply changes silentlly
				var score_string = value + &#x27;&#x2F;&#x27; + min + &#x27;&#x2F;&#x27; + max;
				track.set({&#x27;score&#x27;:score_string});

			}

			return;

		},

		&#x27;isAutomatic&#x27;: function(raw){

			if(_.isUndefined(raw) || _.isNull(raw) || _.isNaN(raw)) return true;
			if(raw ===&#x27;auto&#x27; || raw ===&#x27;none&#x27;) return true;

			return false;
		},
		&#x27;set&#x27;: function(value, track, manager, important){
			
			var raw = manager.get(track.id, this.name, &#x27;raw&#x27;);
			var is_auto = this.isAutomatic(raw);
			if(is_auto) return;

			&#x2F;&#x2F;ok its manual value..
			var score = parseScoreString(track);

			if(!score || score ===&#x27;auto&#x27; || score ===&#x27;none&#x27;) return;

			var is_sum = false;

			if(_.isString(value)){
				if(value.indexOf(&#x27;+&#x27;)===0){
					is_sum = true;
				}
				else if(value.indexOf(&#x27;-&#x27;)===0){
					is_sum = true;
				}
			}

			value = parseFloat(value);

			if(!_.isNumber(value)) return;

			var cval = score.value;

			var result = value;
			if(is_sum) result = cval + value;

			var is_change = (result!=cval)? true : false;

			if(is_change){

				&#x2F;&#x2F;apply changes silentlly
				var score_string = result + &#x27;&#x2F;&#x27; + score.min + &#x27;&#x2F;&#x27; + score.max;
				track.set({&#x27;score&#x27;:score_string}, {&#x27;silent&#x27;:true});

			}


			&#x2F;&#x2F;realease &#x27;change&#x27; track event
			track.change();	
			
			&#x2F;*
			if(is_change){

				if(result &gt;= score.min){

					if(result &gt; score.max){
						manager.set(track.id, &#x27;status&#x27;, STATUS.BONUS);
					}
					else if(track.get(&#x27;status&#x27;)&lt;STATUS.PASSED){
						manager.set(track.id, &#x27;status&#x27;, STATUS.PASSED);
					}	
						
				}

			}*&#x2F;

		
			&#x2F;&#x2F;return resulting value
			return result;

		},

		&#x27;onchange&#x27;: function(track, trackman){

			&#x2F;&#x2F;get reffering node
			var node = trackman.document.getNodeById(track.id);

			var parent = node.parent();

			if(parent &amp;&amp; parent.isTracking(this.name)) trackman.refresh(parent.id,this.name);

			return;

		}


	};



	&#x2F;&#x2F;expose
	smx.tracking.TrackDataTypes = AttributeController;


})(window.smx);;(function(smx){


	var TrackManager = function(doc){

		&#x2F;&#x2F;document &amp;&amp; playhead params are required
		if(!doc) return;

		&#x2F;&#x2F;extend with Backbone Events
		_.extend(this, Backbone.Events);

		&#x2F;&#x2F;set document
		this.document = doc;

		&#x2F;&#x2F;set playhead
		this.playhead = this.document.playhead;

		this.collection = new Backbone.Collection();

		this.attrControllers = smx.tracking.attributes;

		this.initializeDocument();

		return this;

	};

	TrackManager.prototype.initializeDocument = function(){

		&#x2F;&#x2F;get the nodes that will have a track
		&#x2F;&#x2F;actually whole document content nodes
		var nodes = this.document.find(&#x27;*&#x27;);
		
		&#x2F;&#x2F;add document node itself to list
		nodes.unshift(this.document);

		&#x2F;&#x2F; create a track for each node
		for (var n=0; n&lt;nodes.length; n++){

			var node = nodes[n];

			var is_tracking = node.isTracking();

			if (is_tracking){

				var attrs = node[0].attributes;

				&#x2F;&#x2F;create empty object for tracking attributes
				var track_attrs = {};

				&#x2F;&#x2F;add node id
				track_attrs.id = node.id;

				&#x2F;&#x2F;add all attributes which names start with &#x27;track-&#x27; 
				for(var i = 0; i &lt; attrs.length; i++) {
					var attr_name = attrs[i].name;
					var attr_value = attrs[i].value;
					if(attr_name.indexOf(&quot;track-&quot;) == 0){
						attr_name = attr_name.substr(6);
						track_attrs[attr_name] = attr_value;
					}
						
				}

				if (node.parent()) track_attrs.parent = node.parent().id;

				&#x2F;&#x2F;create a new Track with catched attributes
				var track = new smx.tracking.Track(track_attrs);

				&#x2F;&#x2F;add just created to track to collection
				this.collection.add(track);


			}


		}


		&#x2F;&#x2F;set collection changes observer
		this.collection.on(&#x27;change&#x27;,_.bind(this.onCollectionChange,this));

		&#x2F;&#x2F;set playhead observers
		this.playhead.on(&#x27;enter&#x27;,_.bind(this.onNodeEnter,this));
		this.playhead.on(&#x27;exit&#x27;,_.bind(this.onNodeExit,this));

		&#x2F;&#x2F;set timeline observers
		this.playhead.on(&#x27;timeline:enter&#x27;,_.bind(this.onNodeEnter,this));
		this.playhead.on(&#x27;timeline:exit&#x27;,_.bind(this.onNodeExit,this));
		this.playhead.on(&#x27;timeline:play&#x27;,_.bind(this.onTimelinePlay,this));
		this.playhead.on(&#x27;timeline:pause&#x27;,_.bind(this.onTimelinePause,this));
		this.playhead.on(&#x27;timeline:update&#x27;,_.bind(this.onTimelineUpdate,this));


		return this;

	};



	&#x2F;**
	 *	Get raw value for specified node id and attribute key
	 *	Uses SMXNode &#x27;raw&#x27; method
	 *
     *  @method raw
     *  @param id {string} node id
     *  @param key {string} attribute key
     *  @return {string} resulting value or null
     *
  	 *&#x2F;

	TrackManager.prototype.raw = function(id, key){

		&#x2F;&#x2F;if bad params return undefined
		if (!id || !key) return;

		&#x2F;&#x2F;get node by id
		var node = this.document.getNodeById(id);

		&#x2F;&#x2F;if not found node return undefined
		if (!node) return;

		&#x2F;&#x2F;return value or undefined
		return node.raw(&#x27;track-&#x27;+ key);

	};


	&#x2F;**
	 *	Answer this question:
	 *	Has key attribute the node with give id?
	 *
     *  @method has
     *  @param id {String} node id
     *  @param key {String} attribute key
     *  @return {Boolean} has or not the specified key
     *
  	 *&#x2F;

	TrackManager.prototype.has = function(id, key){

		&#x2F;&#x2F;if bad params return false
		if (!id || !key) return false;

		&#x2F;&#x2F;get node by id
		var node = this.document.getNodeById(id);

		&#x2F;&#x2F;if not found node return false
		if (!node) return false;

		&#x2F;&#x2F;get raw value by key
		var value = node.raw(&#x27;track-&#x27;+ key);

		&#x2F;&#x2F;raw will always return String or null value
		return (_.isString(value))? true : false;

	};


	TrackManager.prototype.get = function(id, key, format){

		&#x2F;&#x2F;if bad params return undefined
		if (!id || !key) return;

		&#x2F;&#x2F;get track by id
		var track = this.collection.get(id);

		&#x2F;&#x2F;if not found track return undefined
		if (!track) return;

		&#x2F;&#x2F;if track has no key attr return undefined
		if (!this.has(id,key)) return;

		&#x2F;&#x2F;get attr controller
		var attrController = this.attrControllers[key];

		&#x2F;&#x2F;get value
		var value;

		&#x2F;&#x2F;if exists attr controller and has get method use it
		&#x2F;&#x2F;else use default get method
		if(attrController &amp;&amp; attrController.get) 	value = attrController.get(track, this, format);
		else 										value = track.get(key);

		&#x2F;&#x2F;return resultant value
		return value;

	};

	TrackManager.prototype.set = function(id, key, value){

		&#x2F;&#x2F;if bad params exit
		if (!id || !key || typeof value == &#x27;undefined&#x27;) return;

		&#x2F;&#x2F;get track by id
		var track = this.collection.get(id);

		&#x2F;&#x2F;if not found track exit
		if (!track) return;

		&#x2F;&#x2F;if track has no key attr exit
		if (!this.has(id,key)) return;

		&#x2F;&#x2F;get attr controller
		var attrController = this.attrControllers[key];

		&#x2F;&#x2F;if exists attr controller and has set method use it
		&#x2F;&#x2F;else use default set method
		if(attrController &amp;&amp; attrController.set)	return attrController.set(value, track, this);
		else										return track.set(key, value);

	};



	TrackManager.prototype.update = function(id, key){

		&#x2F;&#x2F;get track by given id
		var track = this.collection.get(id);

		&#x2F;&#x2F;no track?
		if (!track) return;

		&#x2F;&#x2F;updating keys array
		var keys = [];

		&#x2F;&#x2F;given key? else use all keys,
		if (key) 	keys.push(key);
		else		keys = _.keys(track.attributes);

		&#x2F;&#x2F;update needed keys
		for(var i=0;i&lt;keys.length;i++){
			var handler = this.attrControllers[keys[i]];
			if(handler &amp;&amp; handler.update) handler.update(track, this);			
		}

		return;

	};

	TrackManager.prototype.propagate = function(id, key, recursive){

		&#x2F;&#x2F;get track by given id
		var track = this.collection.get(id);

		&#x2F;&#x2F;no track?
		if (!track) return;

		&#x2F;&#x2F;updating keys array
		var keys = [];

		&#x2F;&#x2F;given key? else use all keys,
		if (key) 	keys.push(key);
		else		keys = _.keys(track.attributes);

		&#x2F;&#x2F;propagate needed keys
		for(var i=0;i&lt;keys.length;i++){
			var handler = this.attrControllers[keys[i]];
			if(handler &amp;&amp; handler.propagate) handler.propagate(track, this, recursive);			
		}

		return;

	};


	TrackManager.prototype.onCollectionChange = function(track){

		
		if(track.changed){

			var previous = track.previousAttributes();

			var keys = _.keys(track.changed);

			&#x2F;*
			for (var i=0; i&lt; keys.length; i++){

				var previous_value = track.changed[keys[i]];

				&#x2F;&#x2F;log it
				&#x2F;&#x2F;console.log(&#x27;#&#x27;+track.id + &#x27;@&#x27;+keys[i]+&#x27;: &#x27;+ previous_value +&#x27; -&gt; &#x27;+ track.get(keys[i]));

				&#x2F;&#x2F;call bubblers
				var handler = this.attrControllers[keys[i]];
				if(handler.propagate){
					handler.propagate(track, this, previous[keys[i]],previous_value);
				}				

			}
			*&#x2F;

			for (var i=0; i&lt; keys.length; i++){

				&#x2F;&#x2F;fire event &#x27;change:trackId:keyId&#x27;
				var strEvent = &#x27;change:&#x27;+ track.id +&#x27;:&#x27;+keys[i];
				this.trigger(strEvent,track);

			}

		}
		

		return;

	};



    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
    &#x2F;&#x2F; PLAYHEAD EVENT HANDLERS

	TrackManager.prototype.onNodeEnter = function(node){

		&#x2F;*

		&#x2F;&#x2F;this is handler for 2 events
		&#x2F;&#x2F;1 - timeline event, recives event object
		&#x2F;&#x2F;2- playhead event, node

		var node = (event.target)? event.target : event;

		&#x2F;&#x2F;get track by node.id
		var track = this.collection.get(node.id);

		&#x2F;&#x2F;valid track is required
		if(!track) return;


		var keys = _.keys(this.attrControllers);

		for (var i=0;i&lt;keys.length;i++){
			if(this.attrControllers[keys[i]].onenter) this.attrControllers[keys[i]].onenter(track,this,event);
		}

		*&#x2F;


		this.update(node.id);


		return;

	};

	TrackManager.prototype.onNodeExit = function(node){

		&#x2F;*
		&#x2F;&#x2F;this is handler for 2 events
		&#x2F;&#x2F;1 - timeline event, recives event object
		&#x2F;&#x2F;2- playhead event, node

		var node = (event.target)? event.target : event;

		&#x2F;&#x2F;get track by node.id
		var track = this.collection.get(node.id);

		&#x2F;&#x2F;valid track is required
		if(!track) return;


		var keys = _.keys(this.attrControllers);

		for (var i=0;i&lt;keys.length;i++){
			if(this.attrControllers[keys[i]].onexit) this.attrControllers[keys[i]].onexit(track,this,event);
		}

		*&#x2F;

		&#x2F;&#x2F;propagate recursively
		this.propagate(node.id,null, true);

		return;

	};

	TrackManager.prototype.onTimelinePlay = function(event){

		&#x2F;*
		&#x2F;&#x2F;this is handler for 2 events
		&#x2F;&#x2F;1 - timeline event, recives event object
		&#x2F;&#x2F;2- playhead event, node

		var node = (event.target)? event.target : event;

		&#x2F;&#x2F;get track by node.id
		var track = this.collection.get(node.id);

		&#x2F;&#x2F;valid track is required
		if(!track) return;


		var keys = _.keys(this.attrControllers);

		for (var i=0;i&lt;keys.length;i++){
			if(this.attrControllers[keys[i]].onplay) this.attrControllers[keys[i]].onplay(track,this,event);
		}
		*&#x2F;

		return;

	};

	TrackManager.prototype.onTimelinePause = function(event){

		&#x2F;*

		&#x2F;&#x2F;this is handler for 2 events
		&#x2F;&#x2F;1 - timeline event, recives event object
		&#x2F;&#x2F;2- playhead event, node

		var node = (event.target)? event.target : event;

		&#x2F;&#x2F;get track by node.id
		var track = this.collection.get(node.id);

		&#x2F;&#x2F;valid track is required
		if(!track) return;


		var keys = _.keys(this.attrControllers);

		for (var i=0;i&lt;keys.length;i++){
			if(this.attrControllers[keys[i]].onpause) this.attrControllers[keys[i]].onpause(track,this,event);
		}

		*&#x2F;
		return;

	};


	TrackManager.prototype.onTimelineUpdate = function(event){

		&#x2F;*
		&#x2F;&#x2F;this is handler for 2 events
		&#x2F;&#x2F;1 - timeline update event, recives event object
		&#x2F;&#x2F;2 - playhead update event, node

		var node = (event.target)? event.target : event;

		&#x2F;&#x2F;get track by node.id
		var track = this.collection.get(node.id);

		&#x2F;&#x2F;valid track is required
		if(!track) return;


		var keys = _.keys(this.attrControllers);

		for (var i=0;i&lt;keys.length;i++){
			if(this.attrControllers[keys[i]].onupdate) this.attrControllers[keys[i]].onupdate(track,this,event);
		}

		*&#x2F;
		return;

	};





	&#x2F;*
		JSON IO API

	*&#x2F;

	TrackManager.prototype.toJSON = function (options){
		
		var defaults = {
			&#x27;format&#x27;:&#x27;json&#x27;, &#x2F;&#x2F; output format [&#x27;json&#x27;|&#x27;text&#x27;]
			&#x27;onlychanged&#x27;: false	&#x2F;&#x2F; if true will only return changed attributes
		}

		options = _.extend(defaults,options);

		var myJSON = [];

		var _this = this;
		this.collection.each(function(item,index){

			var node = _this.document.getNodeById(item.id);

			var isTracking = node.isTracking();

			var obj = {};


			obj.id = item.id;


			&#x2F;&#x2F;ACCESS
			var access_raw = _this.raw(item.id, &quot;access&quot;);
			var access = _this.get(item.id, &quot;access&quot;);

			if (!options.onlychanged) obj[&quot;access&quot;] = access;
			else
				if(!_.isUndefined(access_raw) &amp;&amp; access_raw!=&#x27;none&#x27; &amp;&amp; access_raw!=&#x27;auto&#x27;)
					if(access&gt;0 &amp;&amp; access!=access_raw)
						obj[&quot;access&quot;] = access;			


			&#x2F;&#x2F;VIEWS
			var views_raw = _this.raw(item.id, &quot;views&quot;);
			var views = _this.get(item.id, &quot;views&quot;);

			if (!options.onlychanged) obj[&quot;views&quot;] = views;
			else
				if(!_.isUndefined(views_raw) &amp;&amp; views_raw!=&#x27;none&#x27;)
					if(views&gt;0 &amp;&amp; views!=views_raw)
						obj[&quot;views&quot;] = views;

			&#x2F;&#x2F;PROGRESS
			var progress_raw = _this.raw(item.id, &quot;progress&quot;);
			var progress = _this.get(item.id, &quot;progress&quot;);

			if (!options.onlychanged) obj[&quot;progress&quot;] = progress;
			else
				if(!_.isUndefined(progress_raw) &amp;&amp; progress_raw!=&#x27;none&#x27; &amp;&amp; progress_raw!=&#x27;auto&#x27;)
					if(progress!=progress_raw  &amp;&amp; progress&gt;0)
						obj[&quot;progress&quot;] = progress;

			&#x2F;&#x2F;SCORE
			var score_raw = _this.raw(item.id, &quot;score&quot;);
			var score = _this.get(item.id, &quot;score&quot;,&#x27;string&#x27;);

			if (!options.onlychanged) obj[&quot;score&quot;] = score;
			else
				if(!_.isUndefined(score_raw) &amp;&amp; score_raw!=&#x27;none&#x27; &amp;&amp; score_raw!=&#x27;auto&#x27;)
					if(score!=score_raw)
						obj[&quot;score&quot;] = score;

			&#x2F;&#x2F;STATUS
			var status_raw = _this.raw(item.id, &quot;status&quot;);
			var status = _this.get(item.id, &quot;status&quot;);

			if (!options.onlychanged) obj[&quot;status&quot;] = status;
			else
				if(!_.isUndefined(status_raw) &amp;&amp; status_raw!=&#x27;none&#x27; &amp;&amp; status_raw!=&#x27;auto&#x27;)
					if(status&gt;0 &amp;&amp; status!=status_raw)
						obj[&quot;status&quot;] = status;


			&#x2F;&#x2F;add obj to json
			if (!options.onlychanged) myJSON.push(obj);
			else
				if (_.size(obj)&gt;1) myJSON.push(obj);


		});

		&#x2F;&#x2F;process return value
		if (options.format == &#x27;text&#x27;) myJSON = JSON.stringify(myJSON);

		return myJSON;


	};

	TrackManager.prototype.toJSONString = function (options){

		var myJSON = this.toJSON(options);
		return JSON.stringify(myJSON);
	};

	TrackManager.prototype.setJSON = function (myJSON){
		
		&#x2F;&#x2F;no input param?
		if (!myJSON) return;

		&#x2F;&#x2F;process input param into data object
		var data = null;

		try{
			if (typeof myJSON == &#x27;string&#x27; &amp;&amp; myJSON!=&#x27;&#x27;){
				data = eval( &#x27;(&#x27;+ myJSON +&#x27;)&#x27; );
			}
			else{
				data = myJSON;
			}
		}
		catch(e){}

		&#x2F;&#x2F;no valid data?
		if (!data) return;


		var len = _.size(data);
		for (var i=len-1; i&gt;0;i--){
			&#x2F;&#x2F;try apply processed data
			try{

				var item = data[i];

				var track = this.collection.get(item.id);

				
				if (item.access) 	track.set(&#x27;access&#x27;, item.access, {&#x27;silent&#x27;:true});
				if (item.views) 	track.set(&#x27;views&#x27;, item.views, {&#x27;silent&#x27;:true});
				if (item.progress) 	track.set(&#x27;progress&#x27;, item.progress, {&#x27;silent&#x27;:true});
				if (item.score) 	track.set(&#x27;score&#x27;, item.score, {&#x27;silent&#x27;:true});
				if (item.status) 	track.set(&#x27;status&#x27;, item.status, {&#x27;silent&#x27;:true});
				

				console.log(&#x27;RESTORE :&#x27; + item.id);

			}
			catch(e){
				return e;
			}

		}



	};



	&#x2F;&#x2F;expose
	smx.tracking.TrackManager = TrackManager;


})(window.smx);;(function(smx) {

	&#x2F;&#x2F;just act as namespace for meta module

 	var Meta = {};

 	&#x2F;&#x2F;expose
 	smx.meta = Meta;



})(window.smx);;&#x2F;**
*
*	Metadata Model
*
*	A pluggable model to store metadata from single smx node.
*	Metadata is considered the &quot;public content data&quot; from an smx node
*	
*	Metadata attributes can be named for convenience, attributes defined
*	here are just as basic example temlate.
*
*	Metadata attributes may be instanced dynamically while XML parsing process
*
*	All SMX nodes matching attribute names starting with &quot;meta-&quot; will create an attribute in Metadata Model
*	meta-attr_name=&quot;attr_value&quot;	-&gt;	node.meta.set(&#x27;attr_name&#x27;,&#x27;attr_value&#x27;)
*	meta-title=&quot;...&quot;	-&gt;	node.meta.set(&#x27;title&#x27;,&#x27;...&#x27;)
*	
* 	@class Metadata
*
*&#x2F;

(function() {


	var Metadata = Backbone.Model.extend({

		defaults:{

			&#x27;title&#x27;: undefined,
			
			&#x27;subtitle&#x27;: undefined,
			
			&#x27;description&#x27;: undefined,
			
			&#x27;image&#x27;: undefined,
			
			&#x27;thumbnail&#x27;: undefined,
			
			&#x27;attachments&#x27;: undefined,
			
			&#x27;data&#x27;: undefined

		},

		initialize: function(){
			return this;
		}
		
	});	

	&#x2F;&#x2F;expose
	smx.meta.MetaData = Metadata;

})(window.smx);
;

(function(smx){


	var MetaManager = function(document){

		&#x2F;&#x2F;requires document to be instantiated
		if(!document) return;

		&#x2F;&#x2F;extend this with backbone events funcionality
		_.extend(this, Backbone.Events);

		&#x2F;&#x2F;set source document
		this.document = document;

		&#x2F;&#x2F;creates an empty collection to handle document metadatas
		this.collection = new Backbone.Collection();

		&#x2F;&#x2F;initialize document
		this.initializeDocument();

		&#x2F;&#x2F;return just created object
		return this;

	};


	MetaManager.prototype.initializeDocument = function(){

		&#x2F;&#x2F;add document itself as metadata
		this.addFromNode(this.document);

		var nodes = this.document.find(&#x27;*&#x27;);
		for (var i=0; i&lt; nodes.length; i++){
			var node = nodes[i];
			this.addFromNode(node);
		}

		return this;

	};

	MetaManager.prototype.addFromNode = function(node){

		var attrs = node[0].attributes;
		var meta_attrs = {};

		for(var i = 0; i &lt; attrs.length; i++) {
			var attr_name = attrs[i].name;
			var attr_value = attrs[i].value;
			if(attr_name.indexOf(&quot;meta-&quot;) == 0){
				attr_name = attr_name.substr(5);
				meta_attrs[attr_name] = attr_value;
			}
				
		}

		var meta = new Backbone.Model(_.extend({ &#x27;id&#x27;: node.id},meta_attrs));
		this.collection.add(meta);

		return meta;			

	};

	MetaManager.prototype.get = function(id, key){

		if (!id || !key) return;

		var meta = this.collection.get(id);

		if (!meta) 	return;
		else		return meta.get(key);

	};

	MetaManager.prototype.set = function(id, key, value){

		if (!id || !key || !value) return;

		var meta = this.collection.get(id);

		if (!meta) return;
		else		return meta.set(key,value);

	};


	&#x2F;&#x2F;return MetaManager;
	&#x2F;&#x2F;expose

	smx.meta.MetaManager = MetaManager;



})(window.smx);
;&#x2F;**
 * Sizzle CSS Selector Engine
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http:&#x2F;&#x2F;sizzlejs.com&#x2F;
 *&#x2F;
(function( window, undefined ) {

var i,
	cachedruns,
	Expr,
	getText,
	isXML,
	compile,
	hasDuplicate,
	outermostContext,

	&#x2F;&#x2F; Local document vars
	setDocument,
	document,
	docElem,
	documentIsXML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,
	sortOrder,

	&#x2F;&#x2F; Instance-specific data
	expando = &quot;sizzle&quot; + -(new Date()),
	preferredDoc = window.document,
	support = {},
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),

	&#x2F;&#x2F; General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 &lt;&lt; 31,

	&#x2F;&#x2F; Array methods
	arr = [],
	pop = arr.pop,
	push = arr.push,
	slice = arr.slice,
	&#x2F;&#x2F; Use a stripped-down indexOf if we can&#x27;t use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i &lt; len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},


	&#x2F;&#x2F; Regular expressions

	&#x2F;&#x2F; Whitespace characters http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;css3-selectors&#x2F;#whitespace
	whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;,
	&#x2F;&#x2F; http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;css3-syntax&#x2F;#characters
	characterEncoding = &quot;(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+&quot;,

	&#x2F;&#x2F; Loosely modeled on CSS identifier characters
	&#x2F;&#x2F; An unquoted value should be a CSS identifier http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;css3-selectors&#x2F;#attribute-selectors
	&#x2F;&#x2F; Proper syntax: http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;CSS21&#x2F;syndata.html#value-def-identifier
	identifier = characterEncoding.replace( &quot;w&quot;, &quot;w#&quot; ),

	&#x2F;&#x2F; Acceptable operators http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;selectors&#x2F;#attribute-selectors
	operators = &quot;([*^$|!~]?=)&quot;,
	attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + characterEncoding + &quot;)&quot; + whitespace +
		&quot;*(?:&quot; + operators + whitespace + &quot;*(?:([&#x27;\&quot;])((?:\\\\.|[^\\\\])*?)\\3|(&quot; + identifier + &quot;)|)|)&quot; + whitespace + &quot;*\\]&quot;,

	&#x2F;&#x2F; Prefer arguments quoted,
	&#x2F;&#x2F;   then not containing pseudos&#x2F;brackets,
	&#x2F;&#x2F;   then attribute selectors&#x2F;non-parenthetical expressions,
	&#x2F;&#x2F;   then anything else
	&#x2F;&#x2F; These preferences are here to reduce the number of selectors
	&#x2F;&#x2F;   needing tokenize in the PSEUDO preFilter
	pseudos = &quot;:(&quot; + characterEncoding + &quot;)(?:\\((([&#x27;\&quot;])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|&quot; + attributes.replace( 3, 8 ) + &quot;)*)|.*)\\)|)&quot;,

	&#x2F;&#x2F; Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + whitespace + &quot;+$&quot;, &quot;g&quot; ),

	rcomma = new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ),
	rcombinators = new RegExp( &quot;^&quot; + whitespace + &quot;*([\\x20\\t\\r\\n\\f&gt;+~])&quot; + whitespace + &quot;*&quot; ),
	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( &quot;^&quot; + identifier + &quot;$&quot; ),

	matchExpr = {
		&quot;ID&quot;: new RegExp( &quot;^#(&quot; + characterEncoding + &quot;)&quot; ),
		&quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + characterEncoding + &quot;)&quot; ),
		&quot;NAME&quot;: new RegExp( &quot;^\\[name=[&#x27;\&quot;]?(&quot; + characterEncoding + &quot;)[&#x27;\&quot;]?\\]&quot; ),
		&quot;TAG&quot;: new RegExp( &quot;^(&quot; + characterEncoding.replace( &quot;w&quot;, &quot;w*&quot; ) + &quot;)&quot; ),
		&quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ),
		&quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ),
		&quot;CHILD&quot;: new RegExp( &quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&quot; + whitespace +
			&quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
			&quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
		&#x2F;&#x2F; For use in libraries implementing .is()
		&#x2F;&#x2F; We use this for POS matching in &#x60;select&#x60;
		&quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; +
			whitespace + &quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;, &quot;i&quot; )
	},

	rsibling = &#x2F;[\x20\t\r\n\f]*[+~]&#x2F;,

	rnative = &#x2F;^[^{]+\{\s*\[native code&#x2F;,

	&#x2F;&#x2F; Easily-parseable&#x2F;retrievable ID or TAG or CLASS selectors
	rquickExpr = &#x2F;^(?:#([\w-]+)|(\w+)|\.([\w-]+))$&#x2F;,

	rinputs = &#x2F;^(?:input|select|textarea|button)$&#x2F;i,
	rheader = &#x2F;^h\d$&#x2F;i,

	rescape = &#x2F;&#x27;|\\&#x2F;g,
	rattributeQuotes = &#x2F;\=[\x20\t\r\n\f]*([^&#x27;&quot;\]]*)[\x20\t\r\n\f]*\]&#x2F;g,

	&#x2F;&#x2F; CSS escapes http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;CSS21&#x2F;syndata.html#escaped-characters
	runescape = &#x2F;\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)&#x2F;g,
	funescape = function( _, escaped ) {
		var high = &quot;0x&quot; + escaped - 0x10000;
		&#x2F;&#x2F; NaN means non-codepoint
		return high !== high ?
			escaped :
			&#x2F;&#x2F; BMP codepoint
			high &lt; 0 ?
				String.fromCharCode( high + 0x10000 ) :
				&#x2F;&#x2F; Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high &gt;&gt; 10 | 0xD800, high &amp; 0x3FF | 0xDC00 );
	};

&#x2F;&#x2F; Use a stripped-down slice if we can&#x27;t use a native one
try {
	slice.call( preferredDoc.documentElement.childNodes, 0 )[0].nodeType;
} catch ( e ) {
	slice = function( i ) {
		var elem,
			results = [];
		while ( (elem = this[i++]) ) {
			results.push( elem );
		}
		return results;
	};
}

&#x2F;**
 * For feature detection
 * @param {Function} fn The function to test for native support
 *&#x2F;
function isNative( fn ) {
	return rnative.test( fn + &quot;&quot; );
}

&#x2F;**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 *&#x2F;
function createCache() {
	var cache,
		keys = [];

	return (cache = function( key, value ) {
		&#x2F;&#x2F; Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key += &quot; &quot; ) &gt; Expr.cacheLength ) {
			&#x2F;&#x2F; Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key ] = value);
	});
}

&#x2F;**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 *&#x2F;
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

&#x2F;**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 *&#x2F;
function assert( fn ) {
	var div = document.createElement(&quot;div&quot;);

	try {
		return fn( div );
	} catch (e) {
		return false;
	} finally {
		&#x2F;&#x2F; release memory in IE
		div = null;
	}
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		&#x2F;&#x2F; QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== &quot;string&quot; ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 &amp;&amp; nodeType !== 9 ) {
		return [];
	}

	if ( !documentIsXML &amp;&amp; !seed ) {

		&#x2F;&#x2F; Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			&#x2F;&#x2F; Speed-up: Sizzle(&quot;#ID&quot;)
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					&#x2F;&#x2F; Check parentNode to catch when Blackberry 4.6 returns
					&#x2F;&#x2F; nodes that are no longer in the document #6963
					if ( elem &amp;&amp; elem.parentNode ) {
						&#x2F;&#x2F; Handle the case where IE, Opera, and Webkit return items
						&#x2F;&#x2F; by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					&#x2F;&#x2F; Context is not a document
					if ( context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById( m )) &amp;&amp;
						contains( context, elem ) &amp;&amp; elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			&#x2F;&#x2F; Speed-up: Sizzle(&quot;TAG&quot;)
			} else if ( match[2] ) {
				push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
				return results;

			&#x2F;&#x2F; Speed-up: Sizzle(&quot;.CLASS&quot;)
			} else if ( (m = match[3]) &amp;&amp; support.getByClassName &amp;&amp; context.getElementsByClassName ) {
				push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
				return results;
			}
		}

		&#x2F;&#x2F; QSA path
		if ( support.qsa &amp;&amp; !rbuggyQSA.test(selector) ) {
			old = true;
			nid = expando;
			newContext = context;
			newSelector = nodeType === 9 &amp;&amp; selector;

			&#x2F;&#x2F; qSA works strangely on Element-rooted queries
			&#x2F;&#x2F; We can work around this by specifying an extra ID on the root
			&#x2F;&#x2F; and working up from there (Thanks to Andrew Dupont for the technique)
			&#x2F;&#x2F; IE 8 doesn&#x27;t work on object elements
			if ( nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &quot;object&quot; ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute(&quot;id&quot;)) ) {
					nid = old.replace( rescape, &quot;\\$&amp;&quot; );
				} else {
					context.setAttribute( &quot;id&quot;, nid );
				}
				nid = &quot;[id=&#x27;&quot; + nid + &quot;&#x27;] &quot;;

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) &amp;&amp; context.parentNode || context;
				newSelector = groups.join(&quot;,&quot;);
			}

			if ( newSelector ) {
				try {
					push.apply( results, slice.call( newContext.querySelectorAll(
						newSelector
					), 0 ) );
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute(&quot;id&quot;);
					}
				}
			}
		}
	}

	&#x2F;&#x2F; All others
	return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed );
}

&#x2F;**
 * Detect xml
 * @param {Element|Object} elem An element or a document
 *&#x2F;
isXML = Sizzle.isXML = function( elem ) {
	&#x2F;&#x2F; documentElement is verified for cases where it doesn&#x27;t yet exist
	&#x2F;&#x2F; (such as loading iframes in IE - #4833)
	var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;
};

&#x2F;**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 *&#x2F;
setDocument = Sizzle.setDocument = function( node ) {
	var doc = node ? node.ownerDocument || node : preferredDoc;

	&#x2F;&#x2F; If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	&#x2F;&#x2F; Set our document
	document = doc;
	docElem = doc.documentElement;

	&#x2F;&#x2F; Support tests
	documentIsXML = isXML( doc );

	&#x2F;&#x2F; Check if getElementsByTagName(&quot;*&quot;) returns only elements
	support.tagNameNoComments = assert(function( div ) {
		div.appendChild( doc.createComment(&quot;&quot;) );
		return !div.getElementsByTagName(&quot;*&quot;).length;
	});

	&#x2F;&#x2F; Check if attributes should be retrieved by attribute nodes
	support.attributes = assert(function( div ) {
		div.innerHTML = &quot;&lt;select&gt;&lt;&#x2F;select&gt;&quot;;
		var type = typeof div.lastChild.getAttribute(&quot;multiple&quot;);
		&#x2F;&#x2F; IE8 returns a string for some attributes even when not present
		return type !== &quot;boolean&quot; &amp;&amp; type !== &quot;string&quot;;
	});

	&#x2F;&#x2F; Check if getElementsByClassName can be trusted
	support.getByClassName = assert(function( div ) {
		&#x2F;&#x2F; Opera can&#x27;t find a second classname (in 9.6)
		div.innerHTML = &quot;&lt;div class=&#x27;hidden e&#x27;&gt;&lt;&#x2F;div&gt;&lt;div class=&#x27;hidden&#x27;&gt;&lt;&#x2F;div&gt;&quot;;
		if ( !div.getElementsByClassName || !div.getElementsByClassName(&quot;e&quot;).length ) {
			return false;
		}

		&#x2F;&#x2F; Safari 3.2 caches class attributes and doesn&#x27;t catch changes
		div.lastChild.className = &quot;e&quot;;
		return div.getElementsByClassName(&quot;e&quot;).length === 2;
	});

	&#x2F;&#x2F; Check if getElementById returns elements by name
	&#x2F;&#x2F; Check if getElementsByName privileges form controls or returns elements by ID
	support.getByName = assert(function( div ) {
		&#x2F;&#x2F; Inject content
		div.id = expando + 0;
		div.innerHTML = &quot;&lt;a name=&#x27;&quot; + expando + &quot;&#x27;&gt;&lt;&#x2F;a&gt;&lt;div name=&#x27;&quot; + expando + &quot;&#x27;&gt;&lt;&#x2F;div&gt;&quot;;
		docElem.insertBefore( div, docElem.firstChild );

		&#x2F;&#x2F; Test
		var pass = doc.getElementsByName &amp;&amp;
			&#x2F;&#x2F; buggy browsers will return fewer than the correct 2
			doc.getElementsByName( expando ).length === 2 +
			&#x2F;&#x2F; buggy browsers will return more than the correct 0
			doc.getElementsByName( expando + 0 ).length;
		support.getIdNotName = !doc.getElementById( expando );

		&#x2F;&#x2F; Cleanup
		docElem.removeChild( div );

		return pass;
	});

	&#x2F;&#x2F; IE6&#x2F;7 return modified attributes
	Expr.attrHandle = assert(function( div ) {
		div.innerHTML = &quot;&lt;a href=&#x27;#&#x27;&gt;&lt;&#x2F;a&gt;&quot;;
		return div.firstChild &amp;&amp; typeof div.firstChild.getAttribute !== strundefined &amp;&amp;
			div.firstChild.getAttribute(&quot;href&quot;) === &quot;#&quot;;
	}) ?
		{} :
		{
			&quot;href&quot;: function( elem ) {
				return elem.getAttribute( &quot;href&quot;, 2 );
			},
			&quot;type&quot;: function( elem ) {
				return elem.getAttribute(&quot;type&quot;);
			}
		};

	&#x2F;&#x2F; ID find and filter
	if ( support.getIdNotName ) {
		Expr.find[&quot;ID&quot;] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined &amp;&amp; !documentIsXML ) {
				var m = context.getElementById( id );
				&#x2F;&#x2F; Check parentNode to catch when Blackberry 4.6 returns
				&#x2F;&#x2F; nodes that are no longer in the document #6963
				return m &amp;&amp; m.parentNode ? [m] : [];
			}
		};
		Expr.filter[&quot;ID&quot;] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute(&quot;id&quot;) === attrId;
			};
		};
	} else {
		Expr.find[&quot;ID&quot;] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined &amp;&amp; !documentIsXML ) {
				var m = context.getElementById( id );

				return m ?
					m.id === id || typeof m.getAttributeNode !== strundefined &amp;&amp; m.getAttributeNode(&quot;id&quot;).value === id ?
						[m] :
						undefined :
					[];
			}
		};
		Expr.filter[&quot;ID&quot;] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined &amp;&amp; elem.getAttributeNode(&quot;id&quot;);
				return node &amp;&amp; node.value === attrId;
			};
		};
	}

	&#x2F;&#x2F; Tag
	Expr.find[&quot;TAG&quot;] = support.tagNameNoComments ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			&#x2F;&#x2F; Filter out possible comments
			if ( tag === &quot;*&quot; ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	&#x2F;&#x2F; Name
	Expr.find[&quot;NAME&quot;] = support.getByName &amp;&amp; function( tag, context ) {
		if ( typeof context.getElementsByName !== strundefined ) {
			return context.getElementsByName( name );
		}
	};

	&#x2F;&#x2F; Class
	Expr.find[&quot;CLASS&quot;] = support.getByClassName &amp;&amp; function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined &amp;&amp; !documentIsXML ) {
			return context.getElementsByClassName( className );
		}
	};

	&#x2F;&#x2F; QSA and matchesSelector support

	&#x2F;&#x2F; matchesSelector(:active) reports false when true (IE9&#x2F;Opera 11.5)
	rbuggyMatches = [];

	&#x2F;&#x2F; qSa(:focus) reports false when true (Chrome 21),
	&#x2F;&#x2F; no need to also add to buggyMatches since matches checks buggyQSA
	&#x2F;&#x2F; A support test would require too much code (would include document ready)
	rbuggyQSA = [ &quot;:focus&quot; ];

	if ( (support.qsa = isNative(doc.querySelectorAll)) ) {
		&#x2F;&#x2F; Build QSA regex
		&#x2F;&#x2F; Regex strategy adopted from Diego Perini
		assert(function( div ) {
			&#x2F;&#x2F; Select is set to empty string on purpose
			&#x2F;&#x2F; This is to test IE&#x27;s treatment of not explictly
			&#x2F;&#x2F; setting a boolean content attribute,
			&#x2F;&#x2F; since its presence should be enough
			&#x2F;&#x2F; http:&#x2F;&#x2F;bugs.jquery.com&#x2F;ticket&#x2F;12359
			div.innerHTML = &quot;&lt;select&gt;&lt;option selected=&#x27;&#x27;&gt;&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&quot;;

			&#x2F;&#x2F; IE8 - Some boolean attributes are not treated correctly
			if ( !div.querySelectorAll(&quot;[selected]&quot;).length ) {
				rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:checked|disabled|ismap|multiple|readonly|selected|value)&quot; );
			}

			&#x2F;&#x2F; Webkit&#x2F;Opera - :checked should return selected option elements
			&#x2F;&#x2F; http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;2011&#x2F;REC-css3-selectors-20110929&#x2F;#checked
			&#x2F;&#x2F; IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(&quot;:checked&quot;).length ) {
				rbuggyQSA.push(&quot;:checked&quot;);
			}
		});

		assert(function( div ) {

			&#x2F;&#x2F; Opera 10-12&#x2F;IE8 - ^= $= *= and empty values
			&#x2F;&#x2F; Should not select anything
			div.innerHTML = &quot;&lt;input type=&#x27;hidden&#x27; i=&#x27;&#x27;&#x2F;&gt;&quot;;
			if ( div.querySelectorAll(&quot;[i^=&#x27;&#x27;]&quot;).length ) {
				rbuggyQSA.push( &quot;[*^$]=&quot; + whitespace + &quot;*(?:\&quot;\&quot;|&#x27;&#x27;)&quot; );
			}

			&#x2F;&#x2F; FF 3.5 - :enabled&#x2F;:disabled and hidden elements (hidden elements are still enabled)
			&#x2F;&#x2F; IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(&quot;:enabled&quot;).length ) {
				rbuggyQSA.push( &quot;:enabled&quot;, &quot;:disabled&quot; );
			}

			&#x2F;&#x2F; Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll(&quot;*,:x&quot;);
			rbuggyQSA.push(&quot;,.*:&quot;);
		});
	}

	if ( (support.matchesSelector = isNative( (matches = docElem.matchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.webkitMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			&#x2F;&#x2F; Check to see if it&#x27;s possible to do matchesSelector
			&#x2F;&#x2F; on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, &quot;div&quot; );

			&#x2F;&#x2F; This should fail with an exception
			&#x2F;&#x2F; Gecko does not error, returns false instead
			matches.call( div, &quot;[s!=&#x27;&#x27;]:x&quot; );
			rbuggyMatches.push( &quot;!=&quot;, pseudos );
		});
	}

	rbuggyQSA = new RegExp( rbuggyQSA.join(&quot;|&quot;) );
	rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp( rbuggyMatches.join(&quot;|&quot;) );

	&#x2F;&#x2F; Element contains another
	&#x2F;&#x2F; Purposefully does not implement inclusive descendent
	&#x2F;&#x2F; As in, an element does not contain itself
	contains = isNative(docElem.contains) || docElem.compareDocumentPosition ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b &amp;&amp; b.parentNode;
			return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	&#x2F;&#x2F; Document order sorting
	sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {
		var compare;

		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( (compare = b.compareDocumentPosition &amp;&amp; a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( b )) ) {
			if ( compare &amp; 1 || a.parentNode &amp;&amp; a.parentNode.nodeType === 11 ) {
				if ( a === doc || contains( preferredDoc, a ) ) {
					return -1;
				}
				if ( b === doc || contains( preferredDoc, b ) ) {
					return 1;
				}
				return 0;
			}
			return compare &amp; 4 ? -1 : 1;
		}

		return a.compareDocumentPosition ? -1 : 1;
	} :
	function( a, b ) {
		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		&#x2F;&#x2F; Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		&#x2F;&#x2F; Parentless nodes are either documents or disconnected
		} else if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				0;

		&#x2F;&#x2F; If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		&#x2F;&#x2F; Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		&#x2F;&#x2F; Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			&#x2F;&#x2F; Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			&#x2F;&#x2F; Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	&#x2F;&#x2F; Always assume the presence of duplicates if sort doesn&#x27;t
	&#x2F;&#x2F; pass them to our comparison function (as in Google Chrome).
	hasDuplicate = false;
	[0, 0].sort( sortOrder );
	support.detectDuplicates = hasDuplicate;

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	&#x2F;&#x2F; Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	&#x2F;&#x2F; Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, &quot;=&#x27;$1&#x27;]&quot; );

	&#x2F;&#x2F; rbuggyQSA always contains :focus, so no need for an existence check
	if ( support.matchesSelector &amp;&amp; !documentIsXML &amp;&amp; (!rbuggyMatches || !rbuggyMatches.test(expr)) &amp;&amp; !rbuggyQSA.test(expr) ) {
		try {
			var ret = matches.call( elem, expr );

			&#x2F;&#x2F; IE 9&#x27;s matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					&#x2F;&#x2F; As well, disconnected nodes are said to be in a document
					&#x2F;&#x2F; fragment in IE 9
					elem.document &amp;&amp; elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length &gt; 0;
};

Sizzle.contains = function( context, elem ) {
	&#x2F;&#x2F; Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	var val;

	&#x2F;&#x2F; Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( !documentIsXML ) {
		name = name.toLowerCase();
	}
	if ( (val = Expr.attrHandle[ name ]) ) {
		return val( elem );
	}
	if ( documentIsXML || support.attributes ) {
		return elem.getAttribute( name );
	}
	return ( (val = elem.getAttributeNode( name )) || elem.getAttribute( name ) ) &amp;&amp; elem[ name ] === true ?
		name :
		val &amp;&amp; val.specified ? val.value : null;
};

Sizzle.error = function( msg ) {
	throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg );
};

&#x2F;&#x2F; Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		i = 1,
		j = 0;

	&#x2F;&#x2F; Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		for ( ; (elem = results[i]); i++ ) {
			if ( elem === results[ i - 1 ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	return results;
};

function siblingCheck( a, b ) {
	var cur = b &amp;&amp; a,
		diff = cur &amp;&amp; ( ~b.sourceIndex || MAX_NEGATIVE ) - ( ~a.sourceIndex || MAX_NEGATIVE );

	&#x2F;&#x2F; Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	&#x2F;&#x2F; Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

&#x2F;&#x2F; Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === &quot;input&quot; &amp;&amp; elem.type === type;
	};
}

&#x2F;&#x2F; Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; elem.type === type;
	};
}

&#x2F;&#x2F; Returns a function to use in pseudos for positionals
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			&#x2F;&#x2F; Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

&#x2F;**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 *&#x2F;
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = &quot;&quot;,
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		&#x2F;&#x2F; If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			&#x2F;&#x2F; Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		&#x2F;&#x2F; Use textContent for elements
		&#x2F;&#x2F; innerText usage removed for consistency of new lines (see #11153)
		if ( typeof elem.textContent === &quot;string&quot; ) {
			return elem.textContent;
		} else {
			&#x2F;&#x2F; Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	&#x2F;&#x2F; Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	&#x2F;&#x2F; Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	find: {},

	relative: {
		&quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
		&quot; &quot;: { dir: &quot;parentNode&quot; },
		&quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
		&quot;~&quot;: { dir: &quot;previousSibling&quot; }
	},

	preFilter: {
		&quot;ATTR&quot;: function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			&#x2F;&#x2F; Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || &quot;&quot; ).replace( runescape, funescape );

			if ( match[2] === &quot;~=&quot; ) {
				match[3] = &quot; &quot; + match[3] + &quot; &quot;;
			}

			return match.slice( 0, 4 );
		},

		&quot;CHILD&quot;: function( match ) {
			&#x2F;* matches from matchExpr[&quot;CHILD&quot;]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*&#x2F;
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === &quot;nth&quot; ) {
				&#x2F;&#x2F; nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				&#x2F;&#x2F; numeric x and y parameters for Expr.filter.CHILD
				&#x2F;&#x2F; remember that false&#x2F;true cast respectively to 0&#x2F;1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === &quot;even&quot; || match[3] === &quot;odd&quot; ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === &quot;odd&quot; );

			&#x2F;&#x2F; other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		&quot;PSEUDO&quot;: function( match ) {
			var excess,
				unquoted = !match[5] &amp;&amp; match[2];

			if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) {
				return null;
			}

			&#x2F;&#x2F; Accept quoted arguments as-is
			if ( match[4] ) {
				match[2] = match[4];

			&#x2F;&#x2F; Strip excess characters from unquoted arguments
			} else if ( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp;
				&#x2F;&#x2F; Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &amp;&amp;
				&#x2F;&#x2F; advance to the next closing parenthesis
				(excess = unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) {

				&#x2F;&#x2F; excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			&#x2F;&#x2F; Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		&quot;TAG&quot;: function( nodeName ) {
			if ( nodeName === &quot;*&quot; ) {
				return function() { return true; };
			}

			nodeName = nodeName.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
			};
		},

		&quot;CLASS&quot;: function( className ) {
			var pattern = classCache[ className + &quot; &quot; ];

			return pattern ||
				(pattern = new RegExp( &quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot; )) &amp;&amp;
				classCache( className, function( elem ) {
					return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined &amp;&amp; elem.getAttribute(&quot;class&quot;)) || &quot;&quot; );
				});
		},

		&quot;ATTR&quot;: function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === &quot;!=&quot;;
				}
				if ( !operator ) {
					return true;
				}

				result += &quot;&quot;;

				return operator === &quot;=&quot; ? result === check :
					operator === &quot;!=&quot; ? result !== check :
					operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf( check ) === 0 :
					operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 :
					operator === &quot;$=&quot; ? check &amp;&amp; result.slice( -check.length ) === check :
					operator === &quot;~=&quot; ? ( &quot; &quot; + result + &quot; &quot; ).indexOf( check ) &gt; -1 :
					operator === &quot;|=&quot; ? result === check || result.slice( 0, check.length + 1 ) === check + &quot;-&quot; :
					false;
			};
		},

		&quot;CHILD&quot;: function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== &quot;nth&quot;,
				forward = type.slice( -4 ) !== &quot;last&quot;,
				ofType = what === &quot;of-type&quot;;

			return first === 1 &amp;&amp; last === 0 ?

				&#x2F;&#x2F; Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? &quot;nextSibling&quot; : &quot;previousSibling&quot;,
						parent = elem.parentNode,
						name = ofType &amp;&amp; elem.nodeName.toLowerCase(),
						useCache = !xml &amp;&amp; !ofType;

					if ( parent ) {

						&#x2F;&#x2F; :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								&#x2F;&#x2F; Reverse direction for :only-* (if we haven&#x27;t yet done so)
								start = dir = type === &quot;only&quot; &amp;&amp; !start &amp;&amp; &quot;nextSibling&quot;;
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						&#x2F;&#x2F; non-xml :nth-child(...) stores cache data on &#x60;parent&#x60;
						if ( forward &amp;&amp; useCache ) {
							&#x2F;&#x2F; Seek &#x60;elem&#x60; from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns &amp;&amp; cache[1];
							diff = cache[0] === dirruns &amp;&amp; cache[2];
							node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||

								&#x2F;&#x2F; Fallback to seeking &#x60;elem&#x60; from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								&#x2F;&#x2F; When found, cache indexes on &#x60;parent&#x60; and break
								if ( node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						&#x2F;&#x2F; Use previously-cached element index if available
						} else if ( useCache &amp;&amp; (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) &amp;&amp; cache[0] === dirruns ) {
							diff = cache[1];

						&#x2F;&#x2F; xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							&#x2F;&#x2F; Use the same loop as above to seek &#x60;elem&#x60; from the start
							while ( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) &amp;&amp; ++diff ) {
									&#x2F;&#x2F; Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						&#x2F;&#x2F; Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 &amp;&amp; diff &#x2F; first &gt;= 0 );
					}
				};
		},

		&quot;PSEUDO&quot;: function( pseudo, argument ) {
			&#x2F;&#x2F; pseudo-class names are case-insensitive
			&#x2F;&#x2F; http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;selectors&#x2F;#pseudo-classes
			&#x2F;&#x2F; Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			&#x2F;&#x2F; Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo );

			&#x2F;&#x2F; The user may use createPseudo to indicate that
			&#x2F;&#x2F; arguments are needed to create the filter function
			&#x2F;&#x2F; just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			&#x2F;&#x2F; But maintain support for old signatures
			if ( fn.length &gt; 1 ) {
				args = [ pseudo, pseudo, &quot;&quot;, argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		&#x2F;&#x2F; Potentially complex pseudos
		&quot;not&quot;: markFunction(function( selector ) {
			&#x2F;&#x2F; Trim the selector passed to compile
			&#x2F;&#x2F; to avoid treating leading and trailing
			&#x2F;&#x2F; spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, &quot;$1&quot; ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					&#x2F;&#x2F; Match elements unmatched by &#x60;matcher&#x60;
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		&quot;has&quot;: markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length &gt; 0;
			};
		}),

		&quot;contains&quot;: markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;
			};
		}),

		&#x2F;&#x2F; &quot;Whether an element is represented by a :lang() selector
		&#x2F;&#x2F; is based solely on the element&#x27;s language value
		&#x2F;&#x2F; being equal to the identifier C,
		&#x2F;&#x2F; or beginning with the identifier C immediately followed by &quot;-&quot;.
		&#x2F;&#x2F; The matching of C against the element&#x27;s language value is performed case-insensitively.
		&#x2F;&#x2F; The identifier C does not have to be a valid language name.&quot;
		&#x2F;&#x2F; http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;selectors&#x2F;#lang-pseudo
		&quot;lang&quot;: markFunction( function( lang ) {
			&#x2F;&#x2F; lang value must be a valid identifider
			if ( !ridentifier.test(lang || &quot;&quot;) ) {
				Sizzle.error( &quot;unsupported lang: &quot; + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsXML ?
						elem.getAttribute(&quot;xml:lang&quot;) || elem.getAttribute(&quot;lang&quot;) :
						elem.lang) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + &quot;-&quot; ) === 0;
					}
				} while ( (elem = elem.parentNode) &amp;&amp; elem.nodeType === 1 );
				return false;
			};
		}),

		&#x2F;&#x2F; Miscellaneous
		&quot;target&quot;: function( elem ) {
			var hash = window.location &amp;&amp; window.location.hash;
			return hash &amp;&amp; hash.slice( 1 ) === elem.id;
		},

		&quot;root&quot;: function( elem ) {
			return elem === docElem;
		},

		&quot;focus&quot;: function( elem ) {
			return elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
		},

		&#x2F;&#x2F; Boolean properties
		&quot;enabled&quot;: function( elem ) {
			return elem.disabled === false;
		},

		&quot;disabled&quot;: function( elem ) {
			return elem.disabled === true;
		},

		&quot;checked&quot;: function( elem ) {
			&#x2F;&#x2F; In CSS3, :checked should return both checked and selected elements
			&#x2F;&#x2F; http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;2011&#x2F;REC-css3-selectors-20110929&#x2F;#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected);
		},

		&quot;selected&quot;: function( elem ) {
			&#x2F;&#x2F; Accessing this property makes selected-by-default
			&#x2F;&#x2F; options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		&#x2F;&#x2F; Contents
		&quot;empty&quot;: function( elem ) {
			&#x2F;&#x2F; http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;selectors&#x2F;#empty-pseudo
			&#x2F;&#x2F; :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			&#x2F;&#x2F;   not comment, processing instructions, or others
			&#x2F;&#x2F; Thanks to Diego Perini for the nodeName shortcut
			&#x2F;&#x2F;   Greater than &quot;@&quot; means alpha characters (specifically not starting with &quot;#&quot; or &quot;?&quot;)
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeName &gt; &quot;@&quot; || elem.nodeType === 3 || elem.nodeType === 4 ) {
					return false;
				}
			}
			return true;
		},

		&quot;parent&quot;: function( elem ) {
			return !Expr.pseudos[&quot;empty&quot;]( elem );
		},

		&#x2F;&#x2F; Element&#x2F;input types
		&quot;header&quot;: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		&quot;input&quot;: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		&quot;button&quot;: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;;
		},

		&quot;text&quot;: function( elem ) {
			var attr;
			&#x2F;&#x2F; IE6 and 7 will map elem.type to &#x27;text&#x27; for new HTML5 types (search, etc)
			&#x2F;&#x2F; use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp;
				elem.type === &quot;text&quot; &amp;&amp;
				( (attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === elem.type );
		},

		&#x2F;&#x2F; Position-in-collection
		&quot;first&quot;: createPositionalPseudo(function() {
			return [ 0 ];
		}),

		&quot;last&quot;: createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		&quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument &lt; 0 ? argument + length : argument ];
		}),

		&quot;even&quot;: createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i &lt; length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		&quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i &lt; length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		&quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument &lt; 0 ? argument + length : argument;
			for ( ; --i &gt;= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		&quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument &lt; 0 ? argument + length : argument;
			for ( ; ++i &lt; length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

&#x2F;&#x2F; Add button&#x2F;input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + &quot; &quot; ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		&#x2F;&#x2F; Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				&#x2F;&#x2F; Don&#x27;t consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( tokens = [] );
		}

		matched = false;

		&#x2F;&#x2F; Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,
				&#x2F;&#x2F; Cast descendant combinators to space
				type: match[0].replace( rtrim, &quot; &quot; )
			} );
			soFar = soFar.slice( matched.length );
		}

		&#x2F;&#x2F; Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	&#x2F;&#x2F; Return the length of the invalid excess
	&#x2F;&#x2F; if we&#x27;re just parsing
	&#x2F;&#x2F; Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			&#x2F;&#x2F; Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = &quot;&quot;;
	for ( ; i &lt; len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base &amp;&amp; dir === &quot;parentNode&quot;,
		doneName = done++;

	return combinator.first ?
		&#x2F;&#x2F; Check against closest ancestor&#x2F;preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		&#x2F;&#x2F; Check against all ancestor&#x2F;preceding elements
		function( elem, context, xml ) {
			var data, cache, outerCache,
				dirkey = dirruns + &quot; &quot; + doneName;

			&#x2F;&#x2F; We can&#x27;t set arbitrary data on XML nodes, so they don&#x27;t benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (cache = outerCache[ dir ]) &amp;&amp; cache[0] === dirkey ) {
							if ( (data = cache[1]) === true || data === cachedruns ) {
								return data === true;
							}
						} else {
							cache = outerCache[ dir ] = [ dirkey ];
							cache[1] = matcher( elem, context, xml ) || cachedruns;
							if ( cache[1] === true ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length &gt; 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i &lt; len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter &amp;&amp; !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder &amp;&amp; !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			&#x2F;&#x2F; Get initial elements from seed or context
			elems = seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [] ),

			&#x2F;&#x2F; Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				&#x2F;&#x2F; If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					&#x2F;&#x2F; ...intermediate processing is necessary
					[] :

					&#x2F;&#x2F; ...otherwise use results directly
					results :
				matcherIn;

		&#x2F;&#x2F; Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		&#x2F;&#x2F; Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			&#x2F;&#x2F; Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					&#x2F;&#x2F; Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							&#x2F;&#x2F; Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				&#x2F;&#x2F; Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &amp;&amp;
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) &gt; -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		&#x2F;&#x2F; Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[&quot; &quot;],
		i = leadingRelative ? 1 : 0,

		&#x2F;&#x2F; The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) &gt; -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i &lt; len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			&#x2F;&#x2F; Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				&#x2F;&#x2F; Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j &lt; len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i &gt; 1 &amp;&amp; elementMatcher( matchers ),
					i &gt; 1 &amp;&amp; toSelector( tokens.slice( 0, i - 1 ) ).replace( rtrim, &quot;$1&quot; ),
					matcher,
					i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
					j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),
					j &lt; len &amp;&amp; toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	&#x2F;&#x2F; A counter to specify which element is currently being matched
	var matcherCachedRuns = 0,
		bySet = setMatchers.length &gt; 0,
		byElement = elementMatchers.length &gt; 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = &quot;0&quot;,
				unmatched = seed &amp;&amp; [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				&#x2F;&#x2F; We must always have either seed elements or context
				elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, expandContext &amp;&amp; context.parentNode || context ),
				&#x2F;&#x2F; Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);

			if ( outermost ) {
				outermostContext = context !== document &amp;&amp; context;
				cachedruns = matcherCachedRuns;
			}

			&#x2F;&#x2F; Add elements passing elementMatchers directly to results
			&#x2F;&#x2F; Keep &#x60;i&#x60; a string if there are no elements so &#x60;matchedCount&#x60; will be &quot;00&quot; below
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement &amp;&amp; elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++matcherCachedRuns;
					}
				}

				&#x2F;&#x2F; Track unmatched elements for set filters
				if ( bySet ) {
					&#x2F;&#x2F; They will have gone through all possible matchers
					if ( (elem = !matcher &amp;&amp; elem) ) {
						matchedCount--;
					}

					&#x2F;&#x2F; Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			&#x2F;&#x2F; Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet &amp;&amp; i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					&#x2F;&#x2F; Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount &gt; 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					&#x2F;&#x2F; Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				&#x2F;&#x2F; Add matches to results
				push.apply( results, setMatched );

				&#x2F;&#x2F; Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
					( matchedCount + setMatchers.length ) &gt; 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			&#x2F;&#x2F; Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group &#x2F;* Internal Use Only *&#x2F; ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + &quot; &quot; ];

	if ( !cached ) {
		&#x2F;&#x2F; Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		&#x2F;&#x2F; Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i &lt; len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		match = tokenize( selector );

	if ( !seed ) {
		&#x2F;&#x2F; Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			&#x2F;&#x2F; Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp;
					context.nodeType === 9 &amp;&amp; !documentIsXML &amp;&amp;
					Expr.relative[ tokens[1].type ] ) {

				context = Expr.find[&quot;ID&quot;]( token.matches[0].replace( runescape, funescape ), context )[0];
				if ( !context ) {
					return results;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			&#x2F;&#x2F; Fetch a seed set for right-to-left matching
			i = matchExpr[&quot;needsContext&quot;].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				&#x2F;&#x2F; Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					&#x2F;&#x2F; Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) &amp;&amp; context.parentNode || context
					)) ) {

						&#x2F;&#x2F; If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length &amp;&amp; toSelector( tokens );
						if ( !selector ) {
							push.apply( results, slice.call( seed, 0 ) );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	&#x2F;&#x2F; Compile and execute a filtering function
	&#x2F;&#x2F; Provide &#x60;match&#x60; to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		documentIsXML,
		results,
		rsibling.test( selector )
	);
	return results;
}

&#x2F;&#x2F; Deprecated
Expr.pseudos[&quot;nth&quot;] = Expr.pseudos[&quot;eq&quot;];

&#x2F;&#x2F; Easy API for creating new setFilters
function setFilters() {}
Expr.filters = setFilters.prototype = Expr.pseudos;
Expr.setFilters = new setFilters();

&#x2F;&#x2F; Initialize with the default document
setDocument();

&#x2F;&#x2F; EXPOSE
if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ) {
	define(function() { return Sizzle; });
} else {
	window.Sizzle = Sizzle;
}
&#x2F;&#x2F; EXPOSE

})( window );
;(function(smx){
 


    &#x2F;**
     *  TIME ATTR CONTROLLER
     *  @module TimeAttrController
     *  Plugin Controller for attributes namespace with &#x27;ui&#x27;
     *&#x2F; 



    var TimeAttrController = {


        &#x27;getters&#x27;: {

            &#x27;timeline&#x27;: function(node){
                return (node.attr(&#x27;timeline&#x27;)===&#x27;true&#x27;);
            },

            &#x27;timing&#x27;: function(node){
                return (node.attr(&#x27;timing&#x27;)===&#x27;absolute&#x27;)? &#x27;absolute&#x27;: &#x27;relative&#x27;;
            },

            &#x27;duration&#x27;: function(node){
                return node.attr(&#x27;duration&#x27;);
            },

            &#x27;start&#x27;: function(node){

                var start, force_sync;

                &#x2F;&#x2F;bool flag use or not local value if exists
                if (!force_sync){

                    &#x2F;&#x2F;has local value?                    
                    start = node.attr(&#x27;start&#x27;);
                    if(_.isNumber(start)) return start;

                }

                &#x2F;&#x2F;get it from attribute
                start = parseInt(node.raw(&#x27;start&#x27;));
                if(_.isNaN(start) || start&lt;0) start = 0;

                &#x2F;&#x2F;set local value
                this.start = start;

                &#x2F;&#x2F;return local value
                return start;

            },

            &#x27;offset&#x27;: function(node){

                var offset = 0;
                var timing = this.timing(node);
                var from;

                var start = this.start(node);
               
                if(timing == &#x27;absolute&#x27;){
                &#x2F;&#x2F;absolute timing
                &#x2F;&#x2F;depends on parent node

                    offset = start;

                }else{
                &#x2F;&#x2F;relative timing
                &#x2F;&#x2F;depends on previous sibling node

                    var prev = node.previous();

                    if(prev)    offset = this.offset(prev) + this.duration(prev) + start;
                    else        offset = start;
                   
                }

                if (!from) return offset;

                if(!from.isParentOf(node)) offset = -1;
                else{

                    var parent = node.parent();
                    if(!parent) offset = -1;
                    &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;????????????????????????
                    else if(parent!=from) offset = this.offset(parent,from) + offset;
               
                }
 
                return offset;

            },

            &#x27;end&#x27;: function(node){
               return this.start(node) + this.duration(node);
            }

        },


        &#x27;get&#x27;: function(node,key){

            if (_.isFunction(this.getters[key])){
                return this.getters[key](node);
            }
            else
                return;

        }



    };





    &#x2F;&#x2F;expose into global smx namespace
    smx.TimeAttrController = TimeAttrController;



})(window.smx);;&#x2F;**
*   SMX Node Class
*
*   @Module Node
*
*&#x2F;

(function(smx){
 

    &#x2F;**
     *  UI ATTR CONTROLLER
     *  @module UIAttrController
     *  Plugin Controller for attributes namespaced with &#x27;ui-&#x27;
     *&#x2F; 

    var UIAttrController = {

        &#x27;MEDIA_TYPES&#x27;: [&#x27;screen&#x27;,&#x27;print&#x27;,&#x27;tv&#x27;],

        &#x27;get&#x27;: function(node,key,type){

            &#x2F;&#x2F;resolve &#x27;media&#x27; value
            type = this.normalizeMediaType(type);

            &#x2F;&#x2F;get &#x27;ui-type-key&#x27; attr
            var asset = node.attr(&#x27;ui-&#x27;+ type +&#x27;-&#x27;+ key);

            &#x2F;&#x2F;no typed key? use generic &#x27;ui-key&#x27;
            if (_.isEmpty(asset)) asset = node.attr(&#x27;ui-&#x27;+key);

            &#x2F;&#x2F;resolve asset url
            if (!_.isEmpty(asset))
                return this.resolveURL(node,asset);           

            return;

        },


        &#x27;normalizeMediaType&#x27;: function(type){

            if (_.isEmpty(type)) return this.MEDIA_TYPES[0];

            if (_.contains(this.MEDIA_TYPES,type))
                return type;
            else
                return this.MEDIA_TYPES[0];
           
        },

        &#x27;resolveURL&#x27;: function(node, asset) {

            &#x2F;&#x2F;starts with &#x27;$&#x2F;&#x27; means root app
            if(asset.substr(0,2)==&#x27;$&#x2F;&#x27;) asset = asset.substr(2);
            &#x2F;&#x2F;starts with &#x27;.&#x2F;&#x27; means root document
            else if(asset.substr(0,2)==&#x27;.&#x2F;&#x27;) asset = node.root().get(&#x27;url&#x27;) + asset.substr(2);
            &#x2F;&#x2F;else is relative to node
            else asset = node.get(&#x27;url&#x27;) + asset;

            return asset;

        }

    };


    &#x2F;&#x2F;expose into global smx namespace
    smx.UIAttrController = UIAttrController;



})(window.smx);;&#x2F;**
*
*   @Module Node
*
*&#x2F;

(function(smx){
 


&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; PRIVATE SELECTOR ENGINE SHORTCUT
&#x2F;&#x2F; defined out of constructor, so multiple SMXDocuments will use same shortcut instance
var _SIZZLE = Sizzle;




&#x2F;**
 *  CORE ATTRIBUTES
 *
 *  Every smx node will have these attributes
 *  Default attributes values are overwritten by values in xml
 *
 *  @module SMXCoreAttributes
 *  @submodule SMXNode
 *
 *&#x2F; 

var _ATTRIBUTES = {

    &#x27;id&#x27;: &#x27;&#x27;,

    &#x27;path&#x27;: &#x27;&#x27;,

    &#x27;file&#x27;: &#x27;&#x27;,

    &#x27;type&#x27;:&#x27;smx&#x27;,

    &#x27;category&#x27;:&#x27;&#x27;

};


&#x2F;**
 *  COMPUTED ATTRIBUTES
 *
 *  Function returning calculated values from core attributes
 *
 *  @module SMXComputedAttributes
 *  @submodule SMXNode
 *
 *&#x2F; 

var _COMPUTED_ATTRIBUTES = {

    &#x2F;**
     *  @method uri
     *  Uniform Resource Identifier,&quot;url id&quot;
     *  Calculate url hash path using cummulative ids up to root
     *&#x2F; 

    &#x27;uri&#x27; : function(node){

        var hash = node.id + &#x27;&#x2F;&#x27;;
        var parent = node.parent();
        if (parent) return parent.get(&#x27;uri&#x27;) + hash;
        else        return hash;

    },


    &#x2F;**
     *  @method url
     *  Uniform Resource Locator (url path)
     *  Calculate url folder path using cummulative paths up to root
     *&#x2F;

    &#x27;url&#x27;: function(node){

        var path = node.get(&#x27;path&#x27;);

        var parent = node.parent();

        if (parent){
            if(_.isEmpty(path))
                return parent.get(&#x27;url&#x27;);
            else{

                &#x2F;&#x2F;add trail slash
                var trail = path.substr(-1);
                if (trail != &#x27;&#x2F;&#x27;) path += &#x27;&#x2F;&#x27;;

                return parent.get(&#x27;url&#x27;) + path;
            }
                
        }
        else{

            if(_.isEmpty(path)) return;

            &#x2F;&#x2F;add trail slash
            var trail = path.substr(-1);
            if (trail != &#x27;&#x2F;&#x27;) path += &#x27;&#x2F;&#x27;;

            return path;

        }

    },

    &#x2F;**
     *  @method file
     *  url of xml source file of this node
     *&#x2F;

    &#x27;file&#x27;: function(node){

        var url = &#x27;&#x27;;
        var file = node.attr(&#x27;file&#x27;);
        var parent = node.parent();

        if (_.isEmpty(file)){

            if (!parent) return;
            return parent.get(&#x27;file&#x27;);

        }
        else{

            var url = node.get(&#x27;url&#x27;);
            return url + file;
            

        }

    }

};








&#x2F;&#x2F;private namespace for SMX functions
var fn = {};



&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; ATTRIBUTE GETTERS

fn.AttributeGetters = {


    &#x2F;**
    * 
    *   Get the raw value for specified attribute key in the original xml node
    *
    *   @method raw
    *   @param key {string} The name of the attribute
    *   @return {string} resulting value
    *
    *&#x2F;

    raw:function(key){
          
        return this[0].getAttribute(key);

    },


    &#x2F;**
    * 
    *   Get the value for specified attribute key in attributes collection
    *
    *   @method attr
    *   @param key {string} The name of the attribute
    *   @return {string} resulting value
    *
    *&#x2F;

    attr:function(key){
        
        if(_.isUndefined(this.attributes[key])) return this.raw(key);
        return this.attributes[key];
    },


    &#x2F;**
    * 
    *   Get the value for specified computed attribute key
    *   If there is no computed attribute with given key will use attr method
    *
    *   @method get
    *   @param key {string} The name of the attribute
    *   @return resulting value
    *
    *&#x2F;

    get:function(key){

        &#x2F;&#x2F;key is required to be non empty string
        if(_.isEmpty(key) || !_.isString(key)) return;

        &#x2F;&#x2F;try using defined attribute getter
        var getter = _COMPUTED_ATTRIBUTES[key];

        &#x2F;&#x2F;getter exists?
        if(_.isFunction(getter)){
            return getter(this);
        }

        return this.attr(key);

    }



};






fn.CoreMethods = {

    &#x2F;&#x2F;return serialization of original XML node
    toString: function(){

        &#x2F;&#x2F;return (window.ActiveXObject)? this[0].xml : (new XMLSerializer()).serializeToString(this[0]);

        &#x2F;&#x2F;this looks better for console loggin...
        &#x2F;&#x2F;is this method being used anywhere else?..

        return this.name + &#x27;#&#x27; + this.id;

    },  

     &#x2F;&#x2F;return serialization of original XML node
    getInnerHTML: function(){

        
        var html = [];
        _.each(this.children(), function(item,index){
            html.push( (window.ActiveXObject)? item[0].xml : (new XMLSerializer()).serializeToString(item[0]) );
        });

        return html.join(&#x27;&#x27;);
        

       &#x2F;&#x2F; return this.html();

    }



};


&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; TREE NODE OPERATIONS


fn.TreeNodeMethods = {


    &#x2F;&#x2F; PARENT RELATED OPERATIONS


        &#x2F;**
        *   @method parent
        *&#x2F;
        parent: function(){
            return _SMX(this[0].parentNode);
        },     
        
        &#x2F;**
        *   @method parents
        *&#x2F;
        parents: function(){
        
            if (!this[0].parentNode) return [];
            else{
                var parent = this.parent();
                var parents = [parent];
                while (parent.parent()){
                    parent = parent.parent();
                    parents.unshift(parent);
                }
                return parents;
            }
        },

        &#x2F;**
        *   @method root
        *   Find top most parent
        *&#x2F;

        &#x27;root&#x27;: function(){

            if (this.parent()){

                &#x2F;&#x2F;get all ancestors
                var parents = this.parents();

                &#x2F;&#x2F;return top most parent node
                return parents[0];

            }
            
            return this;

        },


        &#x2F;&#x2F; EXTRA - PARENT RELATED OPERATIONS
       
        &#x2F;**
        *   @method isParentOf
        *&#x2F;
        isParentOf: function(node){
        
            &#x2F;&#x2F;validate given node (smx node required)
            if (!node.parents) return false;

            var parents = node.parents();          
            if (_.contains(parents,this)) return true;
            else return false;

        },

        &#x2F;**
        *   @method isParentOf
        *&#x2F;
        hasParent: function(node){
        
           return (this[0].parentNode)? true : false;

        },


    &#x2F;&#x2F; CHILD RELATED OPERATIONS


        &#x2F;**
        *   @method find
        *&#x2F;
        find: function(selector){

            if (!this[0].childNodes.length&gt;0) return [];
            if (!_.isString(selector) || _.isEmpty(selector)) return [];

            var query = selector || &#x27;&gt;&#x27;;

            &#x2F;&#x2F;get search context
            var nodes = [];
            try{ nodes = _SIZZLE(query,this[0]); }
            catch(e){}      

            &#x2F;&#x2F;return smx node array
            return _SMX(nodes);
        },            


        &#x2F;**
        *   @method children
        *&#x2F;
        children: function(){
            return _SMX(this[0].childNodes);
        },

        
        &#x2F;**
        *   @method first
        *&#x2F;
        first : function(){
            return _SMX(_.first(this[0].childNodes));
        },

        
        &#x2F;**
        *   @method last
        *&#x2F;
        last : function(){
            return _SMX(_.last(this[0].childNodes));
        },

        

        &#x2F;&#x2F; EXTRA - CHILD RELATED OPERATIONS 

        &#x2F;**
        *   @method childAt
        *&#x2F;
        childAt : function(index){
            return _SMX(this[0].childNodes[index]);
        },       




    &#x2F;&#x2F; SIBLING RELATED OPERATIONS


        &#x2F;**
        *   @method next
        *&#x2F;
        next : function(){
            return _SMX(this[0].nextSibling);
        },

        &#x2F;**
        *   @method previous
        *&#x2F;

        previous : function(){
            return _SMX(this[0].previousSibling);
        },
        


    &#x2F;&#x2F; FLAT TREE SIBLINGS

        &#x2F;**
        *   @method getStepBack
        *&#x2F;
        stepBack: function(){

            &#x2F;&#x2F;previousSibling?
            var _prev_sibling_node = this.previous();
            if(_prev_sibling_node) return _prev_sibling_node;
            
            &#x2F;&#x2F;parentNode?
            var _parent_node = this.parent();
            if(_parent_node) return _parent_node;
            
            &#x2F;&#x2F;nothing found...
            return;
            
        },
        
        &#x2F;**
        *   @method getStepForward
        *&#x2F;
        stepForward: function(from_last_child){
            
            &#x2F;&#x2F;in recursive calls indicate if last recursion come from lastChild of its parent
            var _from_last_child = (from_last_child)? from_last_child : false;
            
            &#x2F;&#x2F; 1. use children, trying to get deep inside node
            &#x2F;&#x2F; if (_from_last_child) means we arleady searched on childNodes and avoid it
            &#x2F;&#x2F; we avoid children when content is not smx
            if (!_from_last_child &amp;&amp; this.get(&#x27;type&#x27;)===&#x27;smx&#x27; ){
                var _first_childnode = this.first();
                return _first_childnode;
            }
                
            &#x2F;&#x2F;2. search nextSibling:
            var _next_sibling_node = this.next();
            if(_next_sibling_node) return _next_sibling_node;
            
            &#x2F;&#x2F;3. search on parentNode
            var _parent_node = this.parent();
            if(_parent_node) return _parent_node.stepForward(true);
            
            &#x2F;&#x2F;4. nothing found: return null!!
            return;
            
        }

};






&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; TIMELINE LOGIC

fn.TimelineLogic = {

                
    &#x2F;**
    *   @method isInsideTimeline
    *&#x2F;
    isInTimeline:function(){
        var is_in_timeline = false;
        var is_timeline = this.isTimeline();
        if(is_timeline){
            return false;
        }
        else{
            
            var parent = this.parent();
            while(parent &amp;&amp; !parent.isTimeline()){
                parent = parent.parent();
            }

            if(!parent) return false;
            else if(parent.isTimeline()) return true;
            else return false;

        }

    },


    &#x2F;**
    *   @method synchronize
    *&#x2F;
    synchronize: function(){

        &#x2F;&#x2F;get &#x27;timing&#x27; attribute value
        var sync = this.getTiming();

        &#x2F;&#x2F;check if node need to be sync
        if (!sync || sync == &#x27;none&#x27;){

            this.duration=0;
            this.start=0;

            &#x2F;&#x2F;do not use &#x27;sync&#x27; attribute so flag it with &#x27;is-sync&#x27;
            this[0].setAttribute(&#x27;is-sync&#x27;,&#x27;true&#x27;);

            return;   
        }


        &#x2F;&#x2F;update sync values (start, duration)
        var force_sync = true;
        var duration = this.getDuration(force_sync);
        var start = this.getStart(force_sync);

        return;
    },

                
    &#x2F;**
    *   @method getStart
    *&#x2F;
    getStart : function(force_sync){
    
        &#x2F;&#x2F;bool flag use or not local value if exists
        if (!force_sync){
            &#x2F;&#x2F;has local value?
            if(_.isNumber(this.start)) return this.start;
        }

        &#x2F;&#x2F;get it from attribute
        var start = parseInt(this[0].getAttribute(&#x27;start&#x27;));
        if(_.isNaN(start) || start&lt;0) start = 0;

        &#x2F;&#x2F;set local value
        this.start = start;

        &#x2F;&#x2F;return local value
        return start;
        
    },

                
    &#x2F;**
    *   @method getDuration
    *&#x2F;
    &#x2F;&#x2F;get duration of this node based on getDuration of child nodes
    &#x2F;&#x2F;@return: Number
    getDuration : function(force_sync){
    
        &#x2F;&#x2F;bool flag use or not local value if exists
        if (!force_sync){
            &#x2F;&#x2F;has local value?
            if(_.isNumber(this.duration)) return this.duration;
        }

        &#x2F;&#x2F;has duration attribute?
        var duration = parseInt(this[0].getAttribute(&#x27;duration&#x27;));
        if(_.isNaN(duration) || duration&lt;0) duration = NaN;

        &#x2F;&#x2F;sync start for 
        var start = this.getStart();

        &#x2F;&#x2F;try child summatory
        if (_.isNaN(duration)){
            var childs = this.children();
            childs = childs.reverse();
            if(childs.length&gt;0){
                &#x2F;&#x2F; childs will define duration using 
                &#x2F;&#x2F; the child with the highest offset+duration value
                var max = 0;
                for(var n=0; n&lt;childs.length;n++){
                    var child = childs[n];
                    var sum = child.offset() + child.getDuration(force_sync);
                    if(sum&gt;max) max = sum;
                }
                duration = max;
            }
            else if(!this.getNext() &amp;&amp; !this.getPrevious()){
                duration = 0;
            }
        }

        
        &#x2F;&#x2F;check next sibling dependencies
        if (_.isNaN(duration) &amp;&amp; this.isInTimeline()){

            &#x2F;&#x2F;get parent
            var parent = this.parent();

            if(parent &amp;&amp; _.isNumber(parent.duration)){

                &#x2F;&#x2F;get next sibling with absolute timing 
                var next = this.getNext();
                var target = null;
                while(next &amp;&amp; !target){
                    if(next.getTiming() == &#x27;absolute&#x27;)  target = next;
                    else                                next = next.getNext();
                }

                if(target){
                    if (_.isNumber(target.start) &amp;&amp; _.isNumber(this.start)){
                        duration = parseInt(next.offset()-this.start);    
                        if(_.isNaN(duration) || duration&lt;0) duration=NaN; 
                    }
                }
                else{
                    duration = parseInt(parent.duration-this.start);    
                    if(_.isNaN(duration) || duration&lt;0) duration=NaN; 
                } 
            }
            else{
                duration = NaN;
            }

        }

        if (_.isNaN(duration) &amp;&amp; !this.isInTimeline()){
            duration = 0;                    
        }

        &#x2F;&#x2F;could not determine duration? set to 0
        if(_.isNaN(duration)){
            duration = 0;
        }
        else{
            &#x2F;&#x2F;create sync flag attribute
            this[0].setAttribute(&#x27;is-sync&#x27;,&#x27;true&#x27;);
        }

        &#x2F;&#x2F;set local value
        this.duration = duration;

        &#x2F;&#x2F;return local value
        return this.duration;
        
    },

                
    &#x2F;**
    *   @method offset
    *&#x2F;
    offset : function(from){
    


        
    },

                
    &#x2F;**
    *   @method getEndTime
    *&#x2F;
    getEndTime : function(){
        return this.getStart() + this.getDuration();
    }


};




&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; META INTERFACE
&#x2F;&#x2F; &#x27;meta&#x27; attributes namespace

fn.MetaInterface = {
    
                
    &#x2F;**
    *   @method meta
    *&#x2F;
    meta: function(key){

        &#x2F;&#x2F;if exists MetaManager, use it
        if(METADATA) return METADATA.get(this.id,key);

        &#x2F;&#x2F;else look for key in attributes
        var attrs = this[0].attributes;
        var value = null;
        for(var i = 0; i &lt; attrs.length; i++) {
            var attr_name = attrs[i].name+&#x27;&#x27;;
            var attr_value = attrs[i].name+&#x27;&#x27;;
            if(attr_name.indexOf(&quot;meta-&quot;) == 0){
                attr_name = attr_name.substr(5);
                if(attr_name == key) value = attrs[i].value;
            }
            if(value) i=attrs.length;
        }

        return value;
        
    }


};




&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; TRACK INTERFACE
&#x2F;&#x2F; &#x27;track&#x27; attributes namespace

fn.TrackAttrInterface = {

                            
    &#x2F;**
    *   @method isAccesible
    *&#x2F;
    isAccesible: function(){

        var access_raw = this.track(&#x27;access&#x27;,&#x27;raw&#x27;);

        if(_.isEmpty(access_raw) || access_raw == &#x27;none&#x27;)
            return true;

        var access = parseInt(this.track(&#x27;access&#x27;));

        if(_.isNumber(access) &amp;&amp; access!=0) return false;
        else{

            var parent = this.parent();

            if(parent){
                return parent.isAccesible();        
            }
            else{
                return true;
            }
            
        }

    },

                            
    &#x2F;**
    *   @method track
    *&#x2F;
    track: function(key, format){

        &#x2F;&#x2F;if exists (TRACKING) TrackManager use it
        if(TRACKING) return TRACKING.get(this.id,key,format);

        &#x2F;&#x2F;else look for key in attributes
        var attrs = this[0].attributes;
        var value = null;
        for(var i = 0; i &lt; attrs.length; i++) {
            var attr_name = attrs[i].name+&#x27;&#x27;;
            var attr_value = attrs[i].name+&#x27;&#x27;;
            if(attr_name.indexOf(&quot;track-&quot;) == 0){
                attr_name = attr_name.substr(6);
                if(attr_name == key) value = attrs[i].value;
            }
            if(value) i = attrs.length;
        }

        return value;
        
    },

    &#x2F;**
    *   Returns true if Tracking Module is handling the given key 
    *   @method isTracking
    *   @param {String} key
    *   @return {Boolean} result
    *&#x2F;
    isTracking: function(key){

        if(!key){
        &#x2F;&#x2F;check for root track attr
            var value = this[0].getAttribute(&#x27;track&#x27;);

            if(value==&#x27;none&#x27;) return false;

            return true;

        }
        else{
        &#x2F;&#x2F;check for given key track attr

            &#x2F;&#x2F;get track-key attr value from xml source node
            var value = this[0].getAttribute(&#x27;track-&#x27;+ key);

            if (_.isUndefined(value) || _.isNull(value) || value==&#x27;none&#x27;)
                return false;

            return true;
            

        }

        return;

    }

};





&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; UI ATTRIBUTES INTERFACE
&#x2F;&#x2F; shortcut for UIAttrController.get()

fn.UIAttrInterface = {
                          
    &#x2F;**
    *   @method ui
    *&#x2F;
    ui: function(key,type){

        return smx.UIAttrController.get(this,key,type);

    }


};



&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F; TIME INTERFACE
&#x2F;&#x2F; &#x27;time&#x27; attributes namespace

fn.TimeInterface = {
    
                
    &#x2F;**
    *   @method media
    *&#x2F;
    time: function(key){

        return smx.TimeAttrController.get(this,key);
    }


};




        var METADATA = null;
        var TRACKING = null;



        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; PRIVATE INDEXED NODE LISTING CACHE
        &#x2F;&#x2F; inside constructor so each document uses its own cache
        var INDEX_CACHE = {};




        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; PRIVATE SMX NODE WRAPPER

        var _SMX = function(elems){

            if (elems &amp;&amp; (_.isArray(elems) || !_.isUndefined(elems.length)) &amp;&amp; _.isUndefined(elems.nodeType)) {
                var result = [];
                for (var i=0; i&lt; elems.length; i++){
                    if (elems[i]){
                        var node = (elems[i][0])? elems[i] : _SMXNode(elems[i]);
                        if (node) result.push(node);                     
                    }
                }
                return result;
            }
            else if(elems) {
                if(elems[0])    return elems;
                else            return _SMXNode(elems);
            }
            else return;

        }; 


        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; PRIVATE SMX NODE CONSTRUCTOR FILTER

        var _SMXNode = function(xmlNode){

            var id = null;

            &#x2F;&#x2F;if(!xmlNode) return;
            &#x2F;&#x2F;if (xmlNode.nodeName == &#x27;undefined&#x27;) return;
            &#x2F;&#x2F;if (typeof xmlNode.nodeType == &#x27;undefined&#x27;) return;
            &#x2F;&#x2F;if (xmlNode.nodeType != 1) return;

            &#x2F;&#x2F;is this uncatched try an alternative to
            &#x2F;&#x2F;the 4 conditionals above?
            try{ id = xmlNode.getAttribute(&#x27;id&#x27;) } catch(e){}

            &#x2F;&#x2F;id attr is required!
            if(!id) return;

            &#x2F;&#x2F;Does already exists a node with this id?
            &#x2F;&#x2F;prevent duplicated nodes and return existing one
            if (INDEX_CACHE[id]) return INDEX_CACHE[id];

            &#x2F;&#x2F;create new SMXNode
            var node = new SMXNode(xmlNode);

            &#x2F;&#x2F;add it to nodes cache
            INDEX_CACHE[id] = node;
            
            &#x2F;&#x2F;return just created node
            return node;


        };



        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; PRIVATE SMX NODE CONSTRUCTOR

        var SMXNode = function(xmlNode){

            this[0] = xmlNode;

            &#x2F;&#x2F;console.log(&#x27;NODETYPE:&#x27; + this[0].nodeType);

            this.id = this[0].getAttribute(&#x27;id&#x27;);

            this.name = this[0].nodeName;

            this.attributes = {};

            var _this = this;

            _.each(_ATTRIBUTES,function(value, key, collection){

                _this.attributes[key] = _this[0].getAttribute(key) || value;

            });

            return this;

        };

        _.extend(SMXNode.prototype,fn.CoreMethods);
        _.extend(SMXNode.prototype,fn.TreeNodeMethods);
        _.extend(SMXNode.prototype,fn.AttributeGetters);

        _.extend(SMXNode.prototype,fn.UIAttrInterface);
        _.extend(SMXNode.prototype,fn.MetaInterface);
        _.extend(SMXNode.prototype,fn.TimeInterface);
        _.extend(SMXNode.prototype,fn.TrackAttrInterface);





    var SMXDocument = function(file, path, xml){


        if (!xml) return;

        if (!file) file = &#x27;index.xml&#x27;;
        if (!path) path = &#x27;&#x27;;








        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; INITIALIZE DOCUMENT


        &#x2F;&#x2F;get 1st node with tag body
        var body = xml.getElementsByTagName(&#x27;body&#x27;)[0];




        &#x2F;&#x2F;break parent node in body
        body = body.parentNode.removeChild(body);

        &#x2F;&#x2F;add core attributes
        body.setAttribute(&#x27;file&#x27;,file);
        body.setAttribute(&#x27;path&#x27;,path);


        &#x2F;&#x2F;create Document from body node
        var DOCUMENT = _SMX(body);

        &#x2F;&#x2F;ensure document has been wrapped, check its [0] property
        if (!DOCUMENT || !DOCUMENT[0]) return;

        &#x2F;&#x2F;add document to node indexed cache
        INDEX_CACHE[DOCUMENT.id] = DOCUMENT;


        &#x2F;&#x2F;OVERRIDES DEFAULT NODE METHODS
        &#x2F;&#x2F;WITH DOCUMENT METHODS
        _.extend(DOCUMENT,{
            getNodeById: function(id){ 
                        
                &#x2F;&#x2F;is nodes cache array?
                if(INDEX_CACHE[id]) return INDEX_CACHE[id];

                &#x2F;&#x2F;search in document
                var node = _SIZZLE(&#x27;#&#x27;+id,this[0]);
                if (node.length&gt;0) return _SMX(node[0]);

                &#x2F;&#x2F;not found
                return; 
                  
            }

        });




        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F; DOCUMENT PROTOTYPES


        var PROTO = {};

        try{

            &#x2F;&#x2F;get head element
            var head = xml.getElementsByTagName(&#x27;head&#x27;)[0];

            &#x2F;&#x2F;get all &quot;prototype&quot; elements inside head
            var _prototypes_ = head.getElementsByTagName(&#x27;prototype&#x27;);

            &#x2F;&#x2F;prototypes collection to store evaluated &quot;prototype&quot; elements
            var prototypes = [];

            &#x2F;&#x2F;loop prototype elements and try to evaluate its content
            _.each(_prototypes_, function(item, index, list){

                &#x2F;&#x2F;try evalualting text content and add it to prototypes collection
                try{
                    prototypes.push( eval( &#x27;(&#x27;+ item.firstChild.nodeValue +&#x27;)&#x27; ) );
                    LOG(&#x27;OK EVALUATING PROTOTYPES FROM &quot;&#x27;+ item.getAttribute(&#x27;file&#x27;) +&#x27;&quot;&#x27;);
                }
                catch(e){
                    LOG(&#x27;ERROR EVALUATING PROTOTYPES FROM &quot;&#x27;+ item.getAttribute(&#x27;file&#x27;) +&#x27;&quot;&#x27;);
                }

            });

            &#x2F;&#x2F;loop prototypes collection
            _.each(prototypes, function(item, index, collection){

                &#x2F;&#x2F;loop prototype rules and propagate it into root PROTO object
                _.each(item, function(value, key, list){

                    &#x2F;&#x2F;if key rule exists extend it
                    if(PROTO[key]) _.extend(PROTO[key], value);
                    &#x2F;&#x2F;else create key rule
                    else PROTO[key] = value;

                });

            });

            if (prototypes.length === 0){
                LOG(&#x27;DOCUMENT HAS NO PROTOTYPES&#x27;);
            }
            else{
                LOG(&#x27;DOCUMENT PROTOTYPES PROCESSING COMPLETED&#x27;);   
            }

        }
        catch(e){

            LOG(&#x27;ERROR PROCESSING DOCUMENT PROTOTYPES&#x27;);

        }

                    
        DOCUMENT.proto = PROTO;



        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F;
        &#x2F;&#x2F; APPLY PROTOTYPES
        &#x2F;&#x2F;
        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;


        var getProtoAttributes = function(selector){

            &#x2F;&#x2F;get proto object
            var proto = PROTO[selector];

            &#x2F;&#x2F;proto does not exists
            if(!proto) return;

            &#x2F;&#x2F;create new object extended from proto
            var attrs = _.extend({}, proto);

            &#x2F;&#x2F;check if &#x27;ext&#x27; attribute exists
            &#x2F;&#x2F;&#x27;ext&#x27; is the id of the prototype of which is extended
            if (!_.isUndefined(attrs[&#x27;ext&#x27;])){

                &#x2F;&#x2F;get ext value
                var ext = attrs.ext;

                &#x2F;&#x2F;delete ext attr, so it does not apply to nodes
                &#x2F;&#x2F;delete attrs.ext; equals to undefined is faster than delete
                attrs.ext = undefined;

                &#x2F;&#x2F;get ext proto attributes
                var ext_attrs = getProtoAttributes(ext);

                &#x2F;&#x2F;if ext proto attrs recived, extend attrs with ext attrs
                if (ext_attrs) attrs = _.extend(attrs,ext_attrs);

            }

            return attrs;

        }


        var applyProtoAttributes = function(node,attrs){

            _.each(attrs, function(value,key,list){

                &#x2F;&#x2F;string values is required
                if (!_.isString(value)) return;

                &#x2F;&#x2F;if value starts with &#x27;!&#x27; is taken as important
                &#x2F;&#x2F;important values will overwrite node attribute values
                if (value.indexOf(&#x27;!&#x27;)===0){

                    &#x2F;&#x2F;remove &#x27;!&#x27; so it does not apply to node attributes
                    value = value.substr(1);

                    &#x2F;&#x2F;apply attr value into node
                    node[0].setAttribute(key,value);     

                }
                else{

                    &#x2F;&#x2F;value is taken as default
                    &#x2F;&#x2F;do not apply if node already has key attribute
                    if (!node[0].getAttribute(key))
                        node[0].setAttribute(key,value);

                }



            });


        }


        _.each(PROTO, function(value, key, list){

            &#x2F;&#x2F;get matching nodes
            var nodes = DOCUMENT.find(key);

            &#x2F;&#x2F;check document apart, find method does not include document itself for searches
            if (_SIZZLE.matchesSelector(DOCUMENT[0],key)) nodes.unshift(DOCUMENT);

            &#x2F;&#x2F;no matching nodes?
            if (nodes.length===0) return;

            &#x2F;&#x2F;get proto attrs
            var attrs = getProtoAttributes(key);

            &#x2F;&#x2F;apply attrs to each matching node
            _.each(nodes, function(item, index){

                applyProtoAttributes(item,attrs);

            });


        });






        &#x2F;*

        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
        &#x2F;&#x2F;
        &#x2F;&#x2F; SYNCHRONIZE DOCUMENT
        &#x2F;&#x2F;
        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

        &#x2F;&#x2F;this call should synchronize whole document
        &#x2F;&#x2F;by synchronize we are meaning the initialization
        &#x2F;&#x2F;of &#x27;start&#x27; and &#x27;duration&#x27; attributes of a node

        &#x2F;&#x2F;max loop recursion
        var max = 25; var n =0;

        &#x2F;&#x2F;get all unsync nodes
        &#x2F;&#x2F;at this point all nodes should be unsync
        var unsync = DOCUMENT.children(&#x27;* :not([is-sync])&#x27;);

        &#x2F;&#x2F;add document itself to unsync nodes
        unsync.unshift(DOCUMENT);

        &#x2F;&#x2F;count nodes for sync
        var total = unsync.length;

        console.log(&#x27;SYNC &#x27;+ total);

        while( n&lt;max &amp;&amp; unsync.length&gt;0 ){

            &#x2F;&#x2F;reverse nodes array
            &#x2F;&#x2F;sync from end to begin and from inside to outside
            unsync = unsync.reverse();

            &#x2F;&#x2F;loop call &#x27;synchronize&#x27;
            for (var i=0;i&lt;unsync.length;i++){
                unsync[i].synchronize();
            }

            &#x2F;&#x2F;get nodes that still unsync
            unsync = DOCUMENT.children(&#x27;* :not([is-sync])&#x27;);

            console.log(&#x27;SYNC (&#x27;+(total-unsync.length) +&#x27;&#x2F;&#x27;+ total+&#x27;)&#x27;);

            n++;
        }

        if(unsync.length&gt;0)     console.log(&#x27;SYNCHRONIZE FAILED (&#x27;+(total-unsync.length) +&#x27;&#x2F;&#x27;+ total+&#x27;)&#x27;);
        else                    console.log(&#x27;SYNCHRONIZED &#x27;+(total-unsync.length));

        
        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

        *&#x2F;


        &#x2F;&#x2F; SETUP PLAYHEAD
        DOCUMENT.playhead = new smx.Playhead(DOCUMENT);


        &#x2F;&#x2F; SETUP METADATA
        METADATA = new smx.meta.MetaManager(DOCUMENT);
        DOCUMENT.metadata = METADATA;


        &#x2F;&#x2F; SETUP TRACKING
        TRACKING = new smx.tracking.TrackManager(DOCUMENT);
        DOCUMENT.tracking = TRACKING;


        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;

        return DOCUMENT;

    };

    &#x2F;&#x2F;expose

    smx.Document = SMXDocument;



})(window.smx);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
